Space travel is becoming increasingly expensive. Space must be open to citizen scientists and those wishing to unlock the secrets of the universe so that we may better our everyday knowledge of space and science. The ArduSat is a wonderful project that allows out of this world ideas become a reality.

One limiting factor of the ArduSat is the Arduino microcontroller. Arduino is a wonderful tool for prototyping and has a vast community of developers, which makes it a great choice to base a citizen satellite on, but the processing power itself is somewhat weak relative to other space satellites and even other microcontrollers on the market.

In an effort to maintain the large user community of Arduino, but also optimize the size and speed of the components in the satellite, we propose ArduEmu, a solution wherein up to 35 Arduino processors may be simulated on a single Raspberry Pi microcomputer board, although any device capable of running the JVM may be selected for use.

Java was picked as the desired programming language for the ArduEMU Arduino Emulator. Calls to "System" are entirely avoided, as this code must be compatible with any platform capable of running the Java Virtual Machine. The processor is emulated using the compiled machine code output of the standard Arduino programming environment. The memory space in the Ardiuno is simulated using a byte array.

The machine code is then parsed instruction-by-instruction, and the memory is modified by a virtual processor. Certain instructions may be intercepted by the emulator; e.g. any pin outputs or serial outputs will not actually connect to pins. Instead, the emulator has the capability to deal with those calls responsively.

To reduce the high cost of emulation, each Emulator object is recyclable. We implement an object pool in our design to allow for dynamic allocation and reallocation of emulators to specific projects and files. The inputs and outputs to each emulator are disconnected; ergo, one can simply clean the emulator, then attach new I/O classes. The outputs of each emulation session are logged and recorded; these can later be consumed and dumped. Then, they are destroyed.
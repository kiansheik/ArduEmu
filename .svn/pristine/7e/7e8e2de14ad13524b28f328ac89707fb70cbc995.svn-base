
C:\Users\Yousuf\AppData\Local\Temp\build5706169335874375032.tmp\Blink.cpp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800100  0000153e  000015d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000153e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000073  0080013a  0080013a  0000160c  2**0
                  ALLOC
  3 .debug_aranges 000006b8  00000000  00000000  0000160c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000010bb  00000000  00000000  00001cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000089ad  00000000  00000000  00002d7f  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001a48  00000000  00000000  0000b72c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005d10  00000000  00000000  0000d174  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000c10  00000000  00000000  00012e84  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00002078  00000000  00000000  00013a94  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000046af  00000000  00000000  00015b0c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macinfo 000741f0  00000000  00000000  0001a1bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000720  00000000  00000000  0008e3ab  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	timer0_millis = m;
	timer0_overflow_count++;
}

unsigned long millis()
{
       0:	0c 94 75 01 	jmp	0x2ea	; 0x2ea <__ctors_end>

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
       4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
int _serialPeek = -1;
void Serial_::begin(uint16_t baud_count)
{
}

void Serial_::end(void)
       8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
    n += write(*buffer++);
  }
  return n;
}

size_t Print::print(const __FlashStringHelper *ifsh)
       c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
//	Number of bytes, assumes a rx endpoint
u8 USB_Available(u8 ep)
{
	LockEP lock(ep);
	return FifoByteCount();
}
      10:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>

//================================================================================
//================================================================================
//	Mouse

Mouse_::Mouse_(void) : _buttons(0)
      14:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      18:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      1c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      20:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      24:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      28:	0c 94 43 07 	jmp	0xe86	; 0xe86 <__vector_10>
      2c:	0c 94 ca 07 	jmp	0xf94	; 0xf94 <__vector_11>
      30:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      34:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      38:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      3c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      40:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      44:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      48:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      4c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      50:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      54:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      58:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      5c:	0c 94 f1 01 	jmp	0x3e2	; 0x3e2 <__vector_23>
      60:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      64:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      68:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      6c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      70:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      74:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      78:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      7c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      80:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      84:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      88:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      8c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      90:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      94:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      98:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      9c:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a0:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a4:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>
      a8:	0c 94 9d 01 	jmp	0x33a	; 0x33a <__bad_interrupt>

000000ac <port_to_mode_PGM>:
      ac:	00 00 00 00 24 00 27 00 2a 00 2d 00 30 00           ....$.'.*.-.0.

000000ba <port_to_output_PGM>:
      ba:	00 00 00 00 25 00 28 00 2b 00 2e 00 31 00           ....%.(.+...1.

000000c8 <port_to_input_PGM>:
      c8:	00 00 00 00 23 00 26 00 29 00 2c 00 2f 00           ....#.&.).,./.

000000d6 <digital_pin_to_port_PGM>:
      d6:	04 04 04 04 04 03 04 05 02 02 02 02 04 03 02 02     ................
      e6:	02 02 06 06 06 06 06 06 04 04 02 02 02 04           ..............

000000f4 <digital_pin_to_bit_mask_PGM>:
      f4:	04 08 02 01 10 40 80 40 10 20 40 80 40 80 08 02     .....@.@. @.@...
     104:	04 01 80 40 20 10 02 01 10 80 10 20 40 40           ...@ ...... @@

00000112 <digital_pin_to_timer_PGM>:
     112:	00 00 00 02 00 08 0e 00 00 03 04 01 00 0b 00 00     ................
	...

00000130 <analog_pin_to_channel_PGM>:
     130:	07 06 05 04 01 00 08 0a 0b 0c 0d 09                 ............

0000013c <_cdcInterface>:
     13c:	08 0b 00 02 02 02 01 00 09 04 00 00 01 02 02 00     ................
     14c:	00 05 24 00 10 01 05 24 01 01 01 04 24 02 06 05     ..$....$....$...
     15c:	24 06 00 01 07 05 81 03 10 00 40 09 04 01 00 02     $.........@.....
     16c:	0a 00 00 00 07 05 02 02 40 00 00 07 05 83 02 40     ........@......@
	...

0000017e <STRING_LANGUAGE>:
     17e:	04 03 09 04                                         ....

00000182 <STRING_IPRODUCT>:
     182:	22 03 41 00 72 00 64 00 75 00 69 00 6e 00 6f 00     ".A.r.d.u.i.n.o.
     192:	20 00 4d 00 69 00 63 00 72 00 6f 00 20 00 20 00      .M.i.c.r.o. . .
     1a2:	20 00                                                .

000001a4 <STRING_IMANUFACTURER>:
     1a4:	18 03 41 00 72 00 64 00 75 00 69 00 6e 00 6f 00     ..A.r.d.u.i.n.o.
     1b4:	20 00 4c 00 4c 00 43 00                              .L.L.C.

000001bc <USB_DeviceDescriptor>:
     1bc:	12 01 00 02 00 00 00 40 41 23 37 80 00 01 01 02     .......@A#7.....
     1cc:	00 01                                               ..

000001ce <USB_DeviceDescriptorA>:
     1ce:	12 01 00 02 02 00 00 40 41 23 37 80 00 01 01 02     .......@A#7.....
     1de:	00 01                                               ..

000001e0 <_initEndpoints>:
     1e0:	00 c1 80 81 c1                                      .....

000001e5 <_hidReportDescriptor>:
     1e5:	05 01 09 02 a1 01 09 01 a1 00 85 01 05 09 19 01     ................
     1f5:	29 03 15 00 25 01 95 03 75 01 81 02 95 01 75 05     )...%...u.....u.
     205:	81 03 05 01 09 30 09 31 09 38 15 81 25 7f 75 08     .....0.1.8..%.u.
     215:	95 03 81 06 c0 c0 05 01 09 06 a1 01 85 02 05 07     ................
     225:	19 e0 29 e7 15 00 25 01 75 01 95 08 81 02 95 01     ..)...%.u.......
     235:	75 08 81 03 95 06 75 08 15 00 25 65 05 07 19 00     u.....u...%e....
     245:	29 65 81 00 c0                                      )e...

0000024a <_hidInterface>:
     24a:	09 04 02 00 01 03 00 00 00 09 21 01 01 00 01 22     ..........!...."
     25a:	65 00 07 05 84 03 40 00 01                          e.....@..

00000263 <_asciimap>:
	...
     26b:	2a 2b 28 00 00 00 00 00 00 00 00 00 00 00 00 00     *+(.............
	...
     283:	2c 9e b4 a0 a1 a2 a4 34 a6 a7 a5 ae 36 2d 37 38     ,......4....6-78
     293:	27 1e 1f 20 21 22 23 24 25 26 b3 33 b6 2e b7 b8     '.. !"#$%&.3....
     2a3:	9f 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92     ................
     2b3:	93 94 95 96 97 98 99 9a 9b 9c 9d 2f 31 30 a3 ad     .........../10..
     2c3:	35 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12     5...............
     2d3:	13 14 15 16 17 18 19 1a 1b 1c 1d af b1 b0 b5 00     ................
	...

000002e4 <__ctors_start>:
     2e4:	f3 03       	fmuls	r23, r19
     2e6:	7d 06       	cpc	r7, r29
     2e8:	4d 09       	sbc	r20, r13

000002ea <__ctors_end>:
     2ea:	11 24       	eor	r1, r1
     2ec:	1f be       	out	0x3f, r1	; 63
     2ee:	cf ef       	ldi	r28, 0xFF	; 255
     2f0:	da e0       	ldi	r29, 0x0A	; 10
     2f2:	de bf       	out	0x3e, r29	; 62
     2f4:	cd bf       	out	0x3d, r28	; 61

000002f6 <__do_copy_data>:
     2f6:	11 e0       	ldi	r17, 0x01	; 1
     2f8:	a0 e0       	ldi	r26, 0x00	; 0
     2fa:	b1 e0       	ldi	r27, 0x01	; 1
     2fc:	ee e3       	ldi	r30, 0x3E	; 62
     2fe:	f5 e1       	ldi	r31, 0x15	; 21
     300:	02 c0       	rjmp	.+4      	; 0x306 <.do_copy_data_start>

00000302 <.do_copy_data_loop>:
     302:	05 90       	lpm	r0, Z+
     304:	0d 92       	st	X+, r0

00000306 <.do_copy_data_start>:
     306:	aa 33       	cpi	r26, 0x3A	; 58
     308:	b1 07       	cpc	r27, r17
     30a:	d9 f7       	brne	.-10     	; 0x302 <.do_copy_data_loop>

0000030c <__do_clear_bss>:
     30c:	11 e0       	ldi	r17, 0x01	; 1
     30e:	aa e3       	ldi	r26, 0x3A	; 58
     310:	b1 e0       	ldi	r27, 0x01	; 1
     312:	01 c0       	rjmp	.+2      	; 0x316 <.do_clear_bss_start>

00000314 <.do_clear_bss_loop>:
     314:	1d 92       	st	X+, r1

00000316 <.do_clear_bss_start>:
     316:	ad 3a       	cpi	r26, 0xAD	; 173
     318:	b1 07       	cpc	r27, r17
     31a:	e1 f7       	brne	.-8      	; 0x314 <.do_clear_bss_loop>

0000031c <__do_global_ctors>:
     31c:	12 e0       	ldi	r17, 0x02	; 2
     31e:	ca ee       	ldi	r28, 0xEA	; 234
     320:	d2 e0       	ldi	r29, 0x02	; 2
     322:	04 c0       	rjmp	.+8      	; 0x32c <.do_global_ctors_start>

00000324 <.do_global_ctors_loop>:
     324:	22 97       	sbiw	r28, 0x02	; 2
     326:	fe 01       	movw	r30, r28
     328:	0e 94 99 0a 	call	0x1532	; 0x1532 <__tablejump__>

0000032c <.do_global_ctors_start>:
     32c:	c4 3e       	cpi	r28, 0xE4	; 228
     32e:	d1 07       	cpc	r29, r17
     330:	c9 f7       	brne	.-14     	; 0x324 <.do_global_ctors_loop>
     332:	0e 94 be 04 	call	0x97c	; 0x97c <main>
     336:	0c 94 9d 0a 	jmp	0x153a	; 0x153a <_exit>

0000033a <__bad_interrupt>:
     33a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000033e <loop>:
  Serial.begin(9600);
  pinMode(led, OUTPUT);     
}

unsigned int a = 0;
void loop() {
     33e:	0f 93       	push	r16
     340:	1f 93       	push	r17
  a = 2;
     342:	82 e0       	ldi	r24, 0x02	; 2
     344:	90 e0       	ldi	r25, 0x00	; 0
     346:	90 93 3b 01 	sts	0x013B, r25
     34a:	80 93 3a 01 	sts	0x013A, r24
  Serial.print("a = ");
     34e:	09 e8       	ldi	r16, 0x89	; 137
     350:	11 e0       	ldi	r17, 0x01	; 1
     352:	c8 01       	movw	r24, r16
     354:	60 e0       	ldi	r22, 0x00	; 0
     356:	71 e0       	ldi	r23, 0x01	; 1
     358:	0e 94 c7 05 	call	0xb8e	; 0xb8e <Print::print(char const*)>
  Serial.println(a);
     35c:	60 91 3a 01 	lds	r22, 0x013A
     360:	70 91 3b 01 	lds	r23, 0x013B
     364:	c8 01       	movw	r24, r16
     366:	4a e0       	ldi	r20, 0x0A	; 10
     368:	50 e0       	ldi	r21, 0x00	; 0
     36a:	0e 94 aa 05 	call	0xb54	; 0xb54 <Print::println(unsigned int, int)>
  asm(
  "mov r0, %0 \n\t"
    "sub r0, 1 \n\t"
    "mov %0, r0 \n\t"
: 
    "=r" (a));
     36e:	08 2e       	mov	r0, r24
     370:	01 18       	sub	r0, r1
     372:	80 2d       	mov	r24, r0
     374:	90 93 3b 01 	sts	0x013B, r25
     378:	80 93 3a 01 	sts	0x013A, r24
  Serial.print("now a = ");
     37c:	c8 01       	movw	r24, r16
     37e:	65 e0       	ldi	r22, 0x05	; 5
     380:	71 e0       	ldi	r23, 0x01	; 1
     382:	0e 94 c7 05 	call	0xb8e	; 0xb8e <Print::print(char const*)>
  Serial.println(a);
     386:	60 91 3a 01 	lds	r22, 0x013A
     38a:	70 91 3b 01 	lds	r23, 0x013B
     38e:	c8 01       	movw	r24, r16
     390:	4a e0       	ldi	r20, 0x0A	; 10
     392:	50 e0       	ldi	r21, 0x00	; 0
     394:	0e 94 aa 05 	call	0xb54	; 0xb54 <Print::println(unsigned int, int)>

  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
     398:	80 91 0e 01 	lds	r24, 0x010E
     39c:	61 e0       	ldi	r22, 0x01	; 1
     39e:	0e 94 75 03 	call	0x6ea	; 0x6ea <digitalWrite>
  delay(1000);               // wait for a second
     3a2:	68 ee       	ldi	r22, 0xE8	; 232
     3a4:	73 e0       	ldi	r23, 0x03	; 3
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	0e 94 39 02 	call	0x472	; 0x472 <delay>
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
     3ae:	80 91 0e 01 	lds	r24, 0x010E
     3b2:	60 e0       	ldi	r22, 0x00	; 0
     3b4:	0e 94 75 03 	call	0x6ea	; 0x6ea <digitalWrite>
  delay(1000);               // wait for a second
     3b8:	68 ee       	ldi	r22, 0xE8	; 232
     3ba:	73 e0       	ldi	r23, 0x03	; 3
     3bc:	80 e0       	ldi	r24, 0x00	; 0
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	0e 94 39 02 	call	0x472	; 0x472 <delay>
}
     3c4:	1f 91       	pop	r17
     3c6:	0f 91       	pop	r16
     3c8:	08 95       	ret

000003ca <setup>:
int led = 13;

void setup() {
  Serial.begin(9600);
     3ca:	89 e8       	ldi	r24, 0x89	; 137
     3cc:	91 e0       	ldi	r25, 0x01	; 1
     3ce:	60 e8       	ldi	r22, 0x80	; 128
     3d0:	75 e2       	ldi	r23, 0x25	; 37
     3d2:	0e 94 a8 03 	call	0x750	; 0x750 <Serial_::begin(unsigned int)>
  pinMode(led, OUTPUT);     
     3d6:	80 91 0e 01 	lds	r24, 0x010E
     3da:	61 e0       	ldi	r22, 0x01	; 1
     3dc:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <pinMode>
}
     3e0:	08 95       	ret

000003e2 <__vector_23>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
SIGNAL(TIM0_OVF_vect)
#else
SIGNAL(TIMER0_OVF_vect)
#endif
{
     3e2:	1f 92       	push	r1
     3e4:	0f 92       	push	r0
     3e6:	0f b6       	in	r0, 0x3f	; 63
     3e8:	0f 92       	push	r0
     3ea:	11 24       	eor	r1, r1
     3ec:	2f 93       	push	r18
     3ee:	3f 93       	push	r19
     3f0:	8f 93       	push	r24
     3f2:	9f 93       	push	r25
     3f4:	af 93       	push	r26
     3f6:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     3f8:	80 91 40 01 	lds	r24, 0x0140
     3fc:	90 91 41 01 	lds	r25, 0x0141
     400:	a0 91 42 01 	lds	r26, 0x0142
     404:	b0 91 43 01 	lds	r27, 0x0143
	unsigned char f = timer0_fract;
     408:	30 91 44 01 	lds	r19, 0x0144

	m += MILLIS_INC;
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	a1 1d       	adc	r26, r1
     410:	b1 1d       	adc	r27, r1
	f += FRACT_INC;
     412:	23 2f       	mov	r18, r19
     414:	2d 5f       	subi	r18, 0xFD	; 253
	if (f >= FRACT_MAX) {
     416:	2d 37       	cpi	r18, 0x7D	; 125
     418:	20 f0       	brcs	.+8      	; 0x422 <__vector_23+0x40>
		f -= FRACT_MAX;
     41a:	2d 57       	subi	r18, 0x7D	; 125
		m += 1;
     41c:	01 96       	adiw	r24, 0x01	; 1
     41e:	a1 1d       	adc	r26, r1
     420:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
     422:	20 93 44 01 	sts	0x0144, r18
	timer0_millis = m;
     426:	80 93 40 01 	sts	0x0140, r24
     42a:	90 93 41 01 	sts	0x0141, r25
     42e:	a0 93 42 01 	sts	0x0142, r26
     432:	b0 93 43 01 	sts	0x0143, r27
	timer0_overflow_count++;
     436:	80 91 3c 01 	lds	r24, 0x013C
     43a:	90 91 3d 01 	lds	r25, 0x013D
     43e:	a0 91 3e 01 	lds	r26, 0x013E
     442:	b0 91 3f 01 	lds	r27, 0x013F
     446:	01 96       	adiw	r24, 0x01	; 1
     448:	a1 1d       	adc	r26, r1
     44a:	b1 1d       	adc	r27, r1
     44c:	80 93 3c 01 	sts	0x013C, r24
     450:	90 93 3d 01 	sts	0x013D, r25
     454:	a0 93 3e 01 	sts	0x013E, r26
     458:	b0 93 3f 01 	sts	0x013F, r27
}
     45c:	bf 91       	pop	r27
     45e:	af 91       	pop	r26
     460:	9f 91       	pop	r25
     462:	8f 91       	pop	r24
     464:	3f 91       	pop	r19
     466:	2f 91       	pop	r18
     468:	0f 90       	pop	r0
     46a:	0f be       	out	0x3f, r0	; 63
     46c:	0f 90       	pop	r0
     46e:	1f 90       	pop	r1
     470:	18 95       	reti

00000472 <delay>:
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
     472:	9b 01       	movw	r18, r22
     474:	ac 01       	movw	r20, r24
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     476:	7f b7       	in	r23, 0x3f	; 63
	
	cli();
     478:	f8 94       	cli
	m = timer0_overflow_count;
     47a:	80 91 3c 01 	lds	r24, 0x013C
     47e:	90 91 3d 01 	lds	r25, 0x013D
     482:	a0 91 3e 01 	lds	r26, 0x013E
     486:	b0 91 3f 01 	lds	r27, 0x013F
#if defined(TCNT0)
	t = TCNT0;
     48a:	66 b5       	in	r22, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     48c:	a8 9b       	sbis	0x15, 0	; 21
     48e:	05 c0       	rjmp	.+10     	; 0x49a <delay+0x28>
     490:	6f 3f       	cpi	r22, 0xFF	; 255
     492:	19 f0       	breq	.+6      	; 0x49a <delay+0x28>
		m++;
     494:	01 96       	adiw	r24, 0x01	; 1
     496:	a1 1d       	adc	r26, r1
     498:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     49a:	7f bf       	out	0x3f, r23	; 63
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();
     49c:	ba 2f       	mov	r27, r26
     49e:	a9 2f       	mov	r26, r25
     4a0:	98 2f       	mov	r25, r24
     4a2:	88 27       	eor	r24, r24
     4a4:	86 0f       	add	r24, r22
     4a6:	91 1d       	adc	r25, r1
     4a8:	a1 1d       	adc	r26, r1
     4aa:	b1 1d       	adc	r27, r1
     4ac:	62 e0       	ldi	r22, 0x02	; 2
     4ae:	88 0f       	add	r24, r24
     4b0:	99 1f       	adc	r25, r25
     4b2:	aa 1f       	adc	r26, r26
     4b4:	bb 1f       	adc	r27, r27
     4b6:	6a 95       	dec	r22
     4b8:	d1 f7       	brne	.-12     	; 0x4ae <delay+0x3c>
     4ba:	bc 01       	movw	r22, r24
     4bc:	2d c0       	rjmp	.+90     	; 0x518 <delay+0xa6>
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     4be:	ff b7       	in	r31, 0x3f	; 63
	
	cli();
     4c0:	f8 94       	cli
	m = timer0_overflow_count;
     4c2:	80 91 3c 01 	lds	r24, 0x013C
     4c6:	90 91 3d 01 	lds	r25, 0x013D
     4ca:	a0 91 3e 01 	lds	r26, 0x013E
     4ce:	b0 91 3f 01 	lds	r27, 0x013F
#if defined(TCNT0)
	t = TCNT0;
     4d2:	e6 b5       	in	r30, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     4d4:	a8 9b       	sbis	0x15, 0	; 21
     4d6:	05 c0       	rjmp	.+10     	; 0x4e2 <delay+0x70>
     4d8:	ef 3f       	cpi	r30, 0xFF	; 255
     4da:	19 f0       	breq	.+6      	; 0x4e2 <delay+0x70>
		m++;
     4dc:	01 96       	adiw	r24, 0x01	; 1
     4de:	a1 1d       	adc	r26, r1
     4e0:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     4e2:	ff bf       	out	0x3f, r31	; 63
void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
		if (((uint16_t)micros() - start) >= 1000) {
     4e4:	ba 2f       	mov	r27, r26
     4e6:	a9 2f       	mov	r26, r25
     4e8:	98 2f       	mov	r25, r24
     4ea:	88 27       	eor	r24, r24
     4ec:	8e 0f       	add	r24, r30
     4ee:	91 1d       	adc	r25, r1
     4f0:	a1 1d       	adc	r26, r1
     4f2:	b1 1d       	adc	r27, r1
     4f4:	e2 e0       	ldi	r30, 0x02	; 2
     4f6:	88 0f       	add	r24, r24
     4f8:	99 1f       	adc	r25, r25
     4fa:	aa 1f       	adc	r26, r26
     4fc:	bb 1f       	adc	r27, r27
     4fe:	ea 95       	dec	r30
     500:	d1 f7       	brne	.-12     	; 0x4f6 <delay+0x84>
     502:	86 1b       	sub	r24, r22
     504:	97 0b       	sbc	r25, r23
     506:	88 5e       	subi	r24, 0xE8	; 232
     508:	93 40       	sbci	r25, 0x03	; 3
     50a:	c8 f2       	brcs	.-78     	; 0x4be <delay+0x4c>
			ms--;
     50c:	21 50       	subi	r18, 0x01	; 1
     50e:	30 40       	sbci	r19, 0x00	; 0
     510:	40 40       	sbci	r20, 0x00	; 0
     512:	50 40       	sbci	r21, 0x00	; 0
			start += 1000;
     514:	68 51       	subi	r22, 0x18	; 24
     516:	7c 4f       	sbci	r23, 0xFC	; 252

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
     518:	21 15       	cp	r18, r1
     51a:	31 05       	cpc	r19, r1
     51c:	41 05       	cpc	r20, r1
     51e:	51 05       	cpc	r21, r1
     520:	71 f6       	brne	.-100    	; 0x4be <delay+0x4c>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
     522:	08 95       	ret

00000524 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
     524:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
     526:	84 b5       	in	r24, 0x24	; 36
     528:	82 60       	ori	r24, 0x02	; 2
     52a:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
     52c:	84 b5       	in	r24, 0x24	; 36
     52e:	81 60       	ori	r24, 0x01	; 1
     530:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
     532:	85 b5       	in	r24, 0x25	; 37
     534:	82 60       	ori	r24, 0x02	; 2
     536:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
     538:	85 b5       	in	r24, 0x25	; 37
     53a:	81 60       	ori	r24, 0x01	; 1
     53c:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
     53e:	ee e6       	ldi	r30, 0x6E	; 110
     540:	f0 e0       	ldi	r31, 0x00	; 0
     542:	80 81       	ld	r24, Z
     544:	81 60       	ori	r24, 0x01	; 1
     546:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
     548:	e1 e8       	ldi	r30, 0x81	; 129
     54a:	f0 e0       	ldi	r31, 0x00	; 0
     54c:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
     54e:	80 81       	ld	r24, Z
     550:	82 60       	ori	r24, 0x02	; 2
     552:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
     554:	80 81       	ld	r24, Z
     556:	81 60       	ori	r24, 0x01	; 1
     558:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
     55a:	e0 e8       	ldi	r30, 0x80	; 128
     55c:	f0 e0       	ldi	r31, 0x00	; 0
     55e:	80 81       	ld	r24, Z
     560:	81 60       	ori	r24, 0x01	; 1
     562:	80 83       	st	Z, r24
#else
	#warning Timer 2 not finished (may not be present on this CPU)
#endif

#if defined(TCCR3B) && defined(CS31) && defined(WGM30)
	sbi(TCCR3B, CS31);		// set timer 3 prescale factor to 64
     564:	e1 e9       	ldi	r30, 0x91	; 145
     566:	f0 e0       	ldi	r31, 0x00	; 0
     568:	80 81       	ld	r24, Z
     56a:	82 60       	ori	r24, 0x02	; 2
     56c:	80 83       	st	Z, r24
	sbi(TCCR3B, CS30);
     56e:	80 81       	ld	r24, Z
     570:	81 60       	ori	r24, 0x01	; 1
     572:	80 83       	st	Z, r24
	sbi(TCCR3A, WGM30);		// put timer 3 in 8-bit phase correct pwm mode
     574:	e0 e9       	ldi	r30, 0x90	; 144
     576:	f0 e0       	ldi	r31, 0x00	; 0
     578:	80 81       	ld	r24, Z
     57a:	81 60       	ori	r24, 0x01	; 1
     57c:	80 83       	st	Z, r24
#endif

#if defined(TCCR4A) && defined(TCCR4B) && defined(TCCR4D) /* beginning of timer4 block for 32U4 and similar */
	sbi(TCCR4B, CS42);		// set timer4 prescale factor to 64
     57e:	e1 ec       	ldi	r30, 0xC1	; 193
     580:	f0 e0       	ldi	r31, 0x00	; 0
     582:	80 81       	ld	r24, Z
     584:	84 60       	ori	r24, 0x04	; 4
     586:	80 83       	st	Z, r24
	sbi(TCCR4B, CS41);
     588:	80 81       	ld	r24, Z
     58a:	82 60       	ori	r24, 0x02	; 2
     58c:	80 83       	st	Z, r24
	sbi(TCCR4B, CS40);
     58e:	80 81       	ld	r24, Z
     590:	81 60       	ori	r24, 0x01	; 1
     592:	80 83       	st	Z, r24
	sbi(TCCR4D, WGM40);		// put timer 4 in phase- and frequency-correct PWM mode	
     594:	e3 ec       	ldi	r30, 0xC3	; 195
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	80 81       	ld	r24, Z
     59a:	81 60       	ori	r24, 0x01	; 1
     59c:	80 83       	st	Z, r24
	sbi(TCCR4A, PWM4A);		// enable PWM mode for comparator OCR4A
     59e:	e0 ec       	ldi	r30, 0xC0	; 192
     5a0:	f0 e0       	ldi	r31, 0x00	; 0
     5a2:	80 81       	ld	r24, Z
     5a4:	82 60       	ori	r24, 0x02	; 2
     5a6:	80 83       	st	Z, r24
	sbi(TCCR4C, PWM4D);		// enable PWM mode for comparator OCR4D
     5a8:	e2 ec       	ldi	r30, 0xC2	; 194
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	80 81       	ld	r24, Z
     5ae:	81 60       	ori	r24, 0x01	; 1
     5b0:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
     5b2:	ea e7       	ldi	r30, 0x7A	; 122
     5b4:	f0 e0       	ldi	r31, 0x00	; 0
     5b6:	80 81       	ld	r24, Z
     5b8:	84 60       	ori	r24, 0x04	; 4
     5ba:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
     5bc:	80 81       	ld	r24, Z
     5be:	82 60       	ori	r24, 0x02	; 2
     5c0:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
     5c2:	80 81       	ld	r24, Z
     5c4:	81 60       	ori	r24, 0x01	; 1
     5c6:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
     5c8:	80 81       	ld	r24, Z
     5ca:	80 68       	ori	r24, 0x80	; 128
     5cc:	80 83       	st	Z, r24
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
#endif
}
     5ce:	08 95       	ret

000005d0 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
     5d0:	cf 93       	push	r28
     5d2:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
     5d4:	48 2f       	mov	r20, r24
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	ca 01       	movw	r24, r20
     5da:	8c 50       	subi	r24, 0x0C	; 12
     5dc:	9f 4f       	sbci	r25, 0xFF	; 255
     5de:	fc 01       	movw	r30, r24
     5e0:	34 91       	lpm	r19, Z+
	uint8_t port = digitalPinToPort(pin);
     5e2:	4a 52       	subi	r20, 0x2A	; 42
     5e4:	5f 4f       	sbci	r21, 0xFF	; 255
     5e6:	fa 01       	movw	r30, r20
     5e8:	84 91       	lpm	r24, Z+
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
     5ea:	88 23       	and	r24, r24
     5ec:	69 f1       	breq	.+90     	; 0x648 <pinMode+0x78>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	88 0f       	add	r24, r24
     5f2:	99 1f       	adc	r25, r25
     5f4:	fc 01       	movw	r30, r24
     5f6:	e4 55       	subi	r30, 0x54	; 84
     5f8:	ff 4f       	sbci	r31, 0xFF	; 255
     5fa:	a5 91       	lpm	r26, Z+
     5fc:	b4 91       	lpm	r27, Z+
	out = portOutputRegister(port);
     5fe:	fc 01       	movw	r30, r24
     600:	e6 54       	subi	r30, 0x46	; 70
     602:	ff 4f       	sbci	r31, 0xFF	; 255
     604:	c5 91       	lpm	r28, Z+
     606:	d4 91       	lpm	r29, Z+

	if (mode == INPUT) { 
     608:	66 23       	and	r22, r22
     60a:	51 f4       	brne	.+20     	; 0x620 <pinMode+0x50>
		uint8_t oldSREG = SREG;
     60c:	2f b7       	in	r18, 0x3f	; 63
                cli();
     60e:	f8 94       	cli
		*reg &= ~bit;
     610:	8c 91       	ld	r24, X
     612:	93 2f       	mov	r25, r19
     614:	90 95       	com	r25
     616:	89 23       	and	r24, r25
     618:	8c 93       	st	X, r24
		*out &= ~bit;
     61a:	88 81       	ld	r24, Y
     61c:	89 23       	and	r24, r25
     61e:	0b c0       	rjmp	.+22     	; 0x636 <pinMode+0x66>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
     620:	62 30       	cpi	r22, 0x02	; 2
     622:	61 f4       	brne	.+24     	; 0x63c <pinMode+0x6c>
		uint8_t oldSREG = SREG;
     624:	2f b7       	in	r18, 0x3f	; 63
                cli();
     626:	f8 94       	cli
		*reg &= ~bit;
     628:	8c 91       	ld	r24, X
     62a:	93 2f       	mov	r25, r19
     62c:	90 95       	com	r25
     62e:	89 23       	and	r24, r25
     630:	8c 93       	st	X, r24
		*out |= bit;
     632:	88 81       	ld	r24, Y
     634:	83 2b       	or	r24, r19
     636:	88 83       	st	Y, r24
		SREG = oldSREG;
     638:	2f bf       	out	0x3f, r18	; 63
     63a:	06 c0       	rjmp	.+12     	; 0x648 <pinMode+0x78>
	} else {
		uint8_t oldSREG = SREG;
     63c:	9f b7       	in	r25, 0x3f	; 63
                cli();
     63e:	f8 94       	cli
		*reg |= bit;
     640:	8c 91       	ld	r24, X
     642:	83 2b       	or	r24, r19
     644:	8c 93       	st	X, r24
		SREG = oldSREG;
     646:	9f bf       	out	0x3f, r25	; 63
	}
}
     648:	df 91       	pop	r29
     64a:	cf 91       	pop	r28
     64c:	08 95       	ret

0000064e <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
     64e:	88 30       	cpi	r24, 0x08	; 8
     650:	71 f1       	breq	.+92     	; 0x6ae <turnOffPWM+0x60>
     652:	89 30       	cpi	r24, 0x09	; 9
     654:	68 f4       	brcc	.+26     	; 0x670 <turnOffPWM+0x22>
     656:	82 30       	cpi	r24, 0x02	; 2
     658:	31 f1       	breq	.+76     	; 0x6a6 <turnOffPWM+0x58>
     65a:	83 30       	cpi	r24, 0x03	; 3
     65c:	20 f4       	brcc	.+8      	; 0x666 <turnOffPWM+0x18>
     65e:	81 30       	cpi	r24, 0x01	; 1
     660:	09 f0       	breq	.+2      	; 0x664 <turnOffPWM+0x16>
     662:	42 c0       	rjmp	.+132    	; 0x6e8 <turnOffPWM+0x9a>
     664:	1d c0       	rjmp	.+58     	; 0x6a0 <turnOffPWM+0x52>
     666:	83 30       	cpi	r24, 0x03	; 3
     668:	89 f0       	breq	.+34     	; 0x68c <turnOffPWM+0x3e>
     66a:	84 30       	cpi	r24, 0x04	; 4
     66c:	e9 f5       	brne	.+122    	; 0x6e8 <turnOffPWM+0x9a>
     66e:	12 c0       	rjmp	.+36     	; 0x694 <turnOffPWM+0x46>
     670:	8b 30       	cpi	r24, 0x0B	; 11
     672:	59 f1       	breq	.+86     	; 0x6ca <turnOffPWM+0x7c>
     674:	8c 30       	cpi	r24, 0x0C	; 12
     676:	28 f4       	brcc	.+10     	; 0x682 <turnOffPWM+0x34>
     678:	89 30       	cpi	r24, 0x09	; 9
     67a:	e9 f0       	breq	.+58     	; 0x6b6 <turnOffPWM+0x68>
     67c:	8a 30       	cpi	r24, 0x0A	; 10
     67e:	a1 f5       	brne	.+104    	; 0x6e8 <turnOffPWM+0x9a>
     680:	1e c0       	rjmp	.+60     	; 0x6be <turnOffPWM+0x70>
     682:	8c 30       	cpi	r24, 0x0C	; 12
     684:	31 f1       	breq	.+76     	; 0x6d2 <turnOffPWM+0x84>
     686:	8e 30       	cpi	r24, 0x0E	; 14
     688:	79 f5       	brne	.+94     	; 0x6e8 <turnOffPWM+0x9a>
     68a:	29 c0       	rjmp	.+82     	; 0x6de <turnOffPWM+0x90>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
     68c:	80 91 80 00 	lds	r24, 0x0080
     690:	8f 77       	andi	r24, 0x7F	; 127
     692:	03 c0       	rjmp	.+6      	; 0x69a <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
     694:	80 91 80 00 	lds	r24, 0x0080
     698:	8f 7d       	andi	r24, 0xDF	; 223
     69a:	80 93 80 00 	sts	0x0080, r24
     69e:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
     6a0:	84 b5       	in	r24, 0x24	; 36
     6a2:	8f 77       	andi	r24, 0x7F	; 127
     6a4:	02 c0       	rjmp	.+4      	; 0x6aa <turnOffPWM+0x5c>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
     6a6:	84 b5       	in	r24, 0x24	; 36
     6a8:	8f 7d       	andi	r24, 0xDF	; 223
     6aa:	84 bd       	out	0x24, r24	; 36
     6ac:	08 95       	ret
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
		#endif
		
		#if defined(TCCR3A) && defined(COM3A1)
		case  TIMER3A:  cbi(TCCR3A, COM3A1);    break;
     6ae:	80 91 90 00 	lds	r24, 0x0090
     6b2:	8f 77       	andi	r24, 0x7F	; 127
     6b4:	07 c0       	rjmp	.+14     	; 0x6c4 <turnOffPWM+0x76>
		#endif
		#if defined(TCCR3A) && defined(COM3B1)
		case  TIMER3B:  cbi(TCCR3A, COM3B1);    break;
     6b6:	80 91 90 00 	lds	r24, 0x0090
     6ba:	8f 7d       	andi	r24, 0xDF	; 223
     6bc:	03 c0       	rjmp	.+6      	; 0x6c4 <turnOffPWM+0x76>
		#endif
		#if defined(TCCR3A) && defined(COM3C1)
		case  TIMER3C:  cbi(TCCR3A, COM3C1);    break;
     6be:	80 91 90 00 	lds	r24, 0x0090
     6c2:	87 7f       	andi	r24, 0xF7	; 247
     6c4:	80 93 90 00 	sts	0x0090, r24
     6c8:	08 95       	ret
		#endif

		#if defined(TCCR4A) && defined(COM4A1)
		case  TIMER4A:  cbi(TCCR4A, COM4A1);    break;
     6ca:	80 91 c0 00 	lds	r24, 0x00C0
     6ce:	8f 77       	andi	r24, 0x7F	; 127
     6d0:	03 c0       	rjmp	.+6      	; 0x6d8 <turnOffPWM+0x8a>
		#endif					
		#if defined(TCCR4A) && defined(COM4B1)
		case  TIMER4B:  cbi(TCCR4A, COM4B1);    break;
     6d2:	80 91 c0 00 	lds	r24, 0x00C0
     6d6:	8f 7d       	andi	r24, 0xDF	; 223
     6d8:	80 93 c0 00 	sts	0x00C0, r24
     6dc:	08 95       	ret
		#endif
		#if defined(TCCR4A) && defined(COM4C1)
		case  TIMER4C:  cbi(TCCR4A, COM4C1);    break;
		#endif			
		#if defined(TCCR4C) && defined(COM4D1)
		case TIMER4D:	cbi(TCCR4C, COM4D1);	break;
     6de:	80 91 c2 00 	lds	r24, 0x00C2
     6e2:	87 7f       	andi	r24, 0xF7	; 247
     6e4:	80 93 c2 00 	sts	0x00C2, r24
     6e8:	08 95       	ret

000006ea <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     6ea:	ff 92       	push	r15
     6ec:	0f 93       	push	r16
     6ee:	1f 93       	push	r17
     6f0:	f6 2e       	mov	r15, r22
	uint8_t timer = digitalPinToTimer(pin);
     6f2:	48 2f       	mov	r20, r24
     6f4:	50 e0       	ldi	r21, 0x00	; 0
     6f6:	ca 01       	movw	r24, r20
     6f8:	8e 5e       	subi	r24, 0xEE	; 238
     6fa:	9e 4f       	sbci	r25, 0xFE	; 254
     6fc:	fc 01       	movw	r30, r24
     6fe:	24 91       	lpm	r18, Z+
	uint8_t bit = digitalPinToBitMask(pin);
     700:	ca 01       	movw	r24, r20
     702:	8c 50       	subi	r24, 0x0C	; 12
     704:	9f 4f       	sbci	r25, 0xFF	; 255
     706:	fc 01       	movw	r30, r24
     708:	14 91       	lpm	r17, Z+
	uint8_t port = digitalPinToPort(pin);
     70a:	4a 52       	subi	r20, 0x2A	; 42
     70c:	5f 4f       	sbci	r21, 0xFF	; 255
     70e:	fa 01       	movw	r30, r20
     710:	04 91       	lpm	r16, Z+
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
     712:	00 23       	and	r16, r16
     714:	c9 f0       	breq	.+50     	; 0x748 <digitalWrite+0x5e>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     716:	22 23       	and	r18, r18
     718:	19 f0       	breq	.+6      	; 0x720 <digitalWrite+0x36>
     71a:	82 2f       	mov	r24, r18
     71c:	0e 94 27 03 	call	0x64e	; 0x64e <turnOffPWM>

	out = portOutputRegister(port);
     720:	e0 2f       	mov	r30, r16
     722:	f0 e0       	ldi	r31, 0x00	; 0
     724:	ee 0f       	add	r30, r30
     726:	ff 1f       	adc	r31, r31
     728:	e6 54       	subi	r30, 0x46	; 70
     72a:	ff 4f       	sbci	r31, 0xFF	; 255
     72c:	a5 91       	lpm	r26, Z+
     72e:	b4 91       	lpm	r27, Z+

	uint8_t oldSREG = SREG;
     730:	9f b7       	in	r25, 0x3f	; 63
	cli();
     732:	f8 94       	cli

	if (val == LOW) {
     734:	ff 20       	and	r15, r15
     736:	21 f4       	brne	.+8      	; 0x740 <digitalWrite+0x56>
		*out &= ~bit;
     738:	8c 91       	ld	r24, X
     73a:	10 95       	com	r17
     73c:	81 23       	and	r24, r17
     73e:	02 c0       	rjmp	.+4      	; 0x744 <digitalWrite+0x5a>
	} else {
		*out |= bit;
     740:	8c 91       	ld	r24, X
     742:	81 2b       	or	r24, r17
     744:	8c 93       	st	X, r24
	}

	SREG = oldSREG;
     746:	9f bf       	out	0x3f, r25	; 63
}
     748:	1f 91       	pop	r17
     74a:	0f 91       	pop	r16
     74c:	ff 90       	pop	r15
     74e:	08 95       	ret

00000750 <Serial_::begin(unsigned int)>:


int _serialPeek = -1;
void Serial_::begin(uint16_t baud_count)
{
}
     750:	08 95       	ret

00000752 <Serial_::available()>:
}

int Serial_::available(void)
{
	ring_buffer *buffer = &cdc_rx_buffer;
	return (unsigned int)(SERIAL_BUFFER_SIZE + buffer->head - buffer->tail) % SERIAL_BUFFER_SIZE;
     752:	20 91 85 01 	lds	r18, 0x0185
     756:	30 91 86 01 	lds	r19, 0x0186
     75a:	80 91 87 01 	lds	r24, 0x0187
     75e:	90 91 88 01 	lds	r25, 0x0188
     762:	28 1b       	sub	r18, r24
     764:	39 0b       	sbc	r19, r25
     766:	2f 73       	andi	r18, 0x3F	; 63
     768:	30 70       	andi	r19, 0x00	; 0
}
     76a:	c9 01       	movw	r24, r18
     76c:	08 95       	ret

0000076e <Serial_::peek()>:

int Serial_::peek(void)
{
	ring_buffer *buffer = &cdc_rx_buffer;
	if (buffer->head == buffer->tail) {
     76e:	20 91 85 01 	lds	r18, 0x0185
     772:	30 91 86 01 	lds	r19, 0x0186
     776:	80 91 87 01 	lds	r24, 0x0187
     77a:	90 91 88 01 	lds	r25, 0x0188
     77e:	28 17       	cp	r18, r24
     780:	39 07       	cpc	r19, r25
     782:	19 f4       	brne	.+6      	; 0x78a <Serial_::peek()+0x1c>
     784:	2f ef       	ldi	r18, 0xFF	; 255
     786:	3f ef       	ldi	r19, 0xFF	; 255
     788:	09 c0       	rjmp	.+18     	; 0x79c <Serial_::peek()+0x2e>
		return -1;
	} else {
		return buffer->buffer[buffer->tail];
     78a:	e0 91 87 01 	lds	r30, 0x0187
     78e:	f0 91 88 01 	lds	r31, 0x0188
     792:	eb 5b       	subi	r30, 0xBB	; 187
     794:	fe 4f       	sbci	r31, 0xFE	; 254
     796:	80 81       	ld	r24, Z
     798:	28 2f       	mov	r18, r24
     79a:	30 e0       	ldi	r19, 0x00	; 0
	}
}
     79c:	c9 01       	movw	r24, r18
     79e:	08 95       	ret

000007a0 <Serial_::read()>:

int Serial_::read(void)
{
	ring_buffer *buffer = &cdc_rx_buffer;
	// if the head isn't ahead of the tail, we don't have any characters
	if (buffer->head == buffer->tail) {
     7a0:	20 91 85 01 	lds	r18, 0x0185
     7a4:	30 91 86 01 	lds	r19, 0x0186
     7a8:	80 91 87 01 	lds	r24, 0x0187
     7ac:	90 91 88 01 	lds	r25, 0x0188
     7b0:	28 17       	cp	r18, r24
     7b2:	39 07       	cpc	r19, r25
     7b4:	19 f4       	brne	.+6      	; 0x7bc <Serial_::read()+0x1c>
     7b6:	2f ef       	ldi	r18, 0xFF	; 255
     7b8:	3f ef       	ldi	r19, 0xFF	; 255
     7ba:	13 c0       	rjmp	.+38     	; 0x7e2 <Serial_::read()+0x42>
		return -1;
	} else {
		unsigned char c = buffer->buffer[buffer->tail];
     7bc:	e0 91 87 01 	lds	r30, 0x0187
     7c0:	f0 91 88 01 	lds	r31, 0x0188
     7c4:	eb 5b       	subi	r30, 0xBB	; 187
     7c6:	fe 4f       	sbci	r31, 0xFE	; 254
     7c8:	20 81       	ld	r18, Z
		buffer->tail = (unsigned int)(buffer->tail + 1) % SERIAL_BUFFER_SIZE;
     7ca:	80 91 87 01 	lds	r24, 0x0187
     7ce:	90 91 88 01 	lds	r25, 0x0188
     7d2:	01 96       	adiw	r24, 0x01	; 1
     7d4:	8f 73       	andi	r24, 0x3F	; 63
     7d6:	90 70       	andi	r25, 0x00	; 0
     7d8:	90 93 88 01 	sts	0x0188, r25
     7dc:	80 93 87 01 	sts	0x0187, r24
		return c;
     7e0:	30 e0       	ldi	r19, 0x00	; 0
	}	
}
     7e2:	c9 01       	movw	r24, r18
     7e4:	08 95       	ret

000007e6 <global constructors keyed to cdc_rx_buffer>:
     7e6:	10 92 8c 01 	sts	0x018C, r1
     7ea:	10 92 8b 01 	sts	0x018B, r1
     7ee:	88 ee       	ldi	r24, 0xE8	; 232
     7f0:	93 e0       	ldi	r25, 0x03	; 3
     7f2:	a0 e0       	ldi	r26, 0x00	; 0
     7f4:	b0 e0       	ldi	r27, 0x00	; 0
     7f6:	80 93 8d 01 	sts	0x018D, r24
     7fa:	90 93 8e 01 	sts	0x018E, r25
     7fe:	a0 93 8f 01 	sts	0x018F, r26
     802:	b0 93 90 01 	sts	0x0190, r27
     806:	8e e1       	ldi	r24, 0x1E	; 30
     808:	91 e0       	ldi	r25, 0x01	; 1
     80a:	90 93 8a 01 	sts	0x018A, r25
     80e:	80 93 89 01 	sts	0x0189, r24
		result = true;
	delay(10);
	return result;
}

Serial_ Serial;
     812:	08 95       	ret

00000814 <Serial_::write(unsigned char)>:
void Serial_::flush(void)
{
	USB_Flush(CDC_TX);
}

size_t Serial_::write(uint8_t c)
     814:	0f 93       	push	r16
     816:	1f 93       	push	r17
     818:	df 93       	push	r29
     81a:	cf 93       	push	r28
     81c:	0f 92       	push	r0
     81e:	cd b7       	in	r28, 0x3d	; 61
     820:	de b7       	in	r29, 0x3e	; 62
     822:	8c 01       	movw	r16, r24
     824:	69 83       	std	Y+1, r22	; 0x01
	 the connection is closed are lost - just like with a UART. */
	
	// TODO - ZE - check behavior on different OSes and test what happens if an
	// open connection isn't broken cleanly (cable is yanked out, host dies
	// or locks up, or host virtual serial port hangs)
	if (_usbLineInfo.lineState > 0)	{
     826:	80 91 17 01 	lds	r24, 0x0117
     82a:	88 23       	and	r24, r24
     82c:	69 f0       	breq	.+26     	; 0x848 <Serial_::write(unsigned char)+0x34>
		int r = USB_Send(CDC_TX,&c,1);
     82e:	83 e0       	ldi	r24, 0x03	; 3
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	41 e0       	ldi	r20, 0x01	; 1
     838:	50 e0       	ldi	r21, 0x00	; 0
     83a:	0e 94 9e 06 	call	0xd3c	; 0xd3c <USB_Send(unsigned char, void const*, int)>
		if (r > 0) {
     83e:	18 16       	cp	r1, r24
     840:	19 06       	cpc	r1, r25
     842:	14 f4       	brge	.+4      	; 0x848 <Serial_::write(unsigned char)+0x34>
			return r;
     844:	9c 01       	movw	r18, r24
     846:	07 c0       	rjmp	.+14     	; 0x856 <Serial_::write(unsigned char)+0x42>
		} else {
			setWriteError();
			return 0;
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	f8 01       	movw	r30, r16
     84e:	93 83       	std	Z+3, r25	; 0x03
     850:	82 83       	std	Z+2, r24	; 0x02
     852:	20 e0       	ldi	r18, 0x00	; 0
     854:	30 e0       	ldi	r19, 0x00	; 0
		}
	}
	setWriteError();
	return 0;
}
     856:	c9 01       	movw	r24, r18
     858:	0f 90       	pop	r0
     85a:	cf 91       	pop	r28
     85c:	df 91       	pop	r29
     85e:	1f 91       	pop	r17
     860:	0f 91       	pop	r16
     862:	08 95       	ret

00000864 <Serial_::flush()>:
	}	
}

void Serial_::flush(void)
{
	USB_Flush(CDC_TX);
     864:	83 e0       	ldi	r24, 0x03	; 3
     866:	0e 94 73 06 	call	0xce6	; 0xce6 <USB_Flush(unsigned char)>
}
     86a:	08 95       	ret

0000086c <Serial_::accept()>:

void Serial_::end(void)
{
}

void Serial_::accept(void) 
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	12 c0       	rjmp	.+36     	; 0x896 <Serial_::accept()+0x2a>
	// current location of the tail), we're about to overflow the buffer
	// and so we don't write the character or advance the head.

	// while we have room to store a byte
	while (i != buffer->tail) {
		int c = USB_Recv(CDC_RX);
     872:	82 e0       	ldi	r24, 0x02	; 2
     874:	0e 94 fe 05 	call	0xbfc	; 0xbfc <USB_Recv(unsigned char)>
		if (c == -1)
     878:	2f ef       	ldi	r18, 0xFF	; 255
     87a:	8f 3f       	cpi	r24, 0xFF	; 255
     87c:	92 07       	cpc	r25, r18
     87e:	c9 f0       	breq	.+50     	; 0x8b2 <Serial_::accept()+0x46>
			break;	// no more data
		buffer->buffer[buffer->head] = c;
     880:	e0 91 85 01 	lds	r30, 0x0185
     884:	f0 91 86 01 	lds	r31, 0x0186
     888:	eb 5b       	subi	r30, 0xBB	; 187
     88a:	fe 4f       	sbci	r31, 0xFE	; 254
     88c:	80 83       	st	Z, r24
		buffer->head = i;
     88e:	d0 93 86 01 	sts	0x0186, r29
     892:	c0 93 85 01 	sts	0x0185, r28

		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
     896:	c0 91 85 01 	lds	r28, 0x0185
     89a:	d0 91 86 01 	lds	r29, 0x0186
     89e:	21 96       	adiw	r28, 0x01	; 1
     8a0:	cf 73       	andi	r28, 0x3F	; 63
     8a2:	d0 70       	andi	r29, 0x00	; 0
	// just before the tail (meaning that the head would advance to the
	// current location of the tail), we're about to overflow the buffer
	// and so we don't write the character or advance the head.

	// while we have room to store a byte
	while (i != buffer->tail) {
     8a4:	80 91 87 01 	lds	r24, 0x0187
     8a8:	90 91 88 01 	lds	r25, 0x0188
     8ac:	c8 17       	cp	r28, r24
     8ae:	d9 07       	cpc	r29, r25
     8b0:	01 f7       	brne	.-64     	; 0x872 <Serial_::accept()+0x6>
		buffer->buffer[buffer->head] = c;
		buffer->head = i;

		i = (unsigned int)(buffer->head+1) % SERIAL_BUFFER_SIZE;
	}
}
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	08 95       	ret

000008b8 <CDC_GetInterface(unsigned char*)>:
	D_INTERFACE(CDC_DATA_INTERFACE,2,CDC_DATA_INTERFACE_CLASS,0,0),
	D_ENDPOINT(USB_ENDPOINT_OUT(CDC_ENDPOINT_OUT),USB_ENDPOINT_TYPE_BULK,0x40,0),
	D_ENDPOINT(USB_ENDPOINT_IN (CDC_ENDPOINT_IN ),USB_ENDPOINT_TYPE_BULK,0x40,0)
};

int WEAK CDC_GetInterface(u8* interfaceNum)
     8b8:	fc 01       	movw	r30, r24
{
	interfaceNum[0] += 2;	// uses 2
     8ba:	80 81       	ld	r24, Z
     8bc:	8e 5f       	subi	r24, 0xFE	; 254
     8be:	80 83       	st	Z, r24
	return USB_SendControl(TRANSFER_PGM,&_cdcInterface,sizeof(_cdcInterface));
     8c0:	80 e8       	ldi	r24, 0x80	; 128
     8c2:	6c e3       	ldi	r22, 0x3C	; 60
     8c4:	71 e0       	ldi	r23, 0x01	; 1
     8c6:	42 e4       	ldi	r20, 0x42	; 66
     8c8:	50 e0       	ldi	r21, 0x00	; 0
     8ca:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
}
     8ce:	08 95       	ret

000008d0 <CDC_Setup(Setup&)>:

bool WEAK CDC_Setup(Setup& setup)
     8d0:	fc 01       	movw	r30, r24
{
	u8 r = setup.bRequest;
     8d2:	81 81       	ldd	r24, Z+1	; 0x01
	u8 requestType = setup.bmRequestType;
     8d4:	90 81       	ld	r25, Z

	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
     8d6:	91 3a       	cpi	r25, 0xA1	; 161
     8d8:	59 f4       	brne	.+22     	; 0x8f0 <CDC_Setup(Setup&)+0x20>
	{
		if (CDC_GET_LINE_CODING == r)
     8da:	81 32       	cpi	r24, 0x21	; 33
     8dc:	09 f0       	breq	.+2      	; 0x8e0 <CDC_Setup(Setup&)+0x10>
     8de:	4c c0       	rjmp	.+152    	; 0x978 <CDC_Setup(Setup&)+0xa8>
		{
			USB_SendControl(0,(void*)&_usbLineInfo,7);
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	60 e1       	ldi	r22, 0x10	; 16
     8e4:	71 e0       	ldi	r23, 0x01	; 1
     8e6:	47 e0       	ldi	r20, 0x07	; 7
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
     8ee:	42 c0       	rjmp	.+132    	; 0x974 <CDC_Setup(Setup&)+0xa4>
			return true;
		}
	}

	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
     8f0:	91 32       	cpi	r25, 0x21	; 33
     8f2:	09 f0       	breq	.+2      	; 0x8f6 <CDC_Setup(Setup&)+0x26>
     8f4:	41 c0       	rjmp	.+130    	; 0x978 <CDC_Setup(Setup&)+0xa8>
	{
		if (CDC_SET_LINE_CODING == r)
     8f6:	80 32       	cpi	r24, 0x20	; 32
     8f8:	39 f4       	brne	.+14     	; 0x908 <CDC_Setup(Setup&)+0x38>
		{
			USB_RecvControl((void*)&_usbLineInfo,7);
     8fa:	80 e1       	ldi	r24, 0x10	; 16
     8fc:	91 e0       	ldi	r25, 0x01	; 1
     8fe:	67 e0       	ldi	r22, 0x07	; 7
     900:	70 e0       	ldi	r23, 0x00	; 0
     902:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <USB_RecvControl(void*, int)>
     906:	36 c0       	rjmp	.+108    	; 0x974 <CDC_Setup(Setup&)+0xa4>
			return true;
		}

		if (CDC_SET_CONTROL_LINE_STATE == r)
     908:	82 32       	cpi	r24, 0x22	; 34
     90a:	09 f0       	breq	.+2      	; 0x90e <CDC_Setup(Setup&)+0x3e>
     90c:	35 c0       	rjmp	.+106    	; 0x978 <CDC_Setup(Setup&)+0xa8>
		{
			_usbLineInfo.lineState = setup.wValueL;
     90e:	82 81       	ldd	r24, Z+2	; 0x02
     910:	80 93 17 01 	sts	0x0117, r24

			// auto-reset into the bootloader is triggered when the port, already 
			// open at 1200 bps, is closed.  this is the signal to start the watchdog
			// with a relatively long period so it can finish housekeeping tasks
			// like servicing endpoints before the sketch ends
			if (1200 == _usbLineInfo.dwDTERate) {
     914:	80 91 10 01 	lds	r24, 0x0110
     918:	90 91 11 01 	lds	r25, 0x0111
     91c:	a0 91 12 01 	lds	r26, 0x0112
     920:	b0 91 13 01 	lds	r27, 0x0113
     924:	80 5b       	subi	r24, 0xB0	; 176
     926:	94 40       	sbci	r25, 0x04	; 4
     928:	a0 40       	sbci	r26, 0x00	; 0
     92a:	b0 40       	sbci	r27, 0x00	; 0
     92c:	19 f5       	brne	.+70     	; 0x974 <CDC_Setup(Setup&)+0xa4>
				// We check DTR state to determine if host port is open (bit 0 of lineState).
				if ((_usbLineInfo.lineState & 0x01) == 0) {
     92e:	80 91 17 01 	lds	r24, 0x0117
     932:	80 fd       	sbrc	r24, 0
     934:	12 c0       	rjmp	.+36     	; 0x95a <CDC_Setup(Setup&)+0x8a>
					*(uint16_t *)0x0800 = 0x7777;
     936:	87 e7       	ldi	r24, 0x77	; 119
     938:	97 e7       	ldi	r25, 0x77	; 119
     93a:	90 93 01 08 	sts	0x0801, r25
     93e:	80 93 00 08 	sts	0x0800, r24
					wdt_enable(WDTO_120MS);
     942:	2b e0       	ldi	r18, 0x0B	; 11
     944:	88 e1       	ldi	r24, 0x18	; 24
     946:	90 e0       	ldi	r25, 0x00	; 0
     948:	0f b6       	in	r0, 0x3f	; 63
     94a:	f8 94       	cli
     94c:	a8 95       	wdr
     94e:	80 93 60 00 	sts	0x0060, r24
     952:	0f be       	out	0x3f, r0	; 63
     954:	20 93 60 00 	sts	0x0060, r18
     958:	0d c0       	rjmp	.+26     	; 0x974 <CDC_Setup(Setup&)+0xa4>
					// Most OSs do some intermediate steps when configuring ports and DTR can
					// twiggle more than once before stabilizing.
					// To avoid spurious resets we set the watchdog to 250ms and eventually
					// cancel if DTR goes back high.
	
					wdt_disable();
     95a:	88 e1       	ldi	r24, 0x18	; 24
     95c:	0f b6       	in	r0, 0x3f	; 63
     95e:	f8 94       	cli
     960:	80 93 60 00 	sts	0x0060, r24
     964:	10 92 60 00 	sts	0x0060, r1
     968:	0f be       	out	0x3f, r0	; 63
					wdt_reset();
     96a:	a8 95       	wdr
					*(uint16_t *)0x0800 = 0x0;
     96c:	10 92 01 08 	sts	0x0801, r1
     970:	10 92 00 08 	sts	0x0800, r1
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	08 95       	ret
     978:	80 e0       	ldi	r24, 0x00	; 0
			}
			return true;
		}
	}
	return false;
}
     97a:	08 95       	ret

0000097c <main>:
#include <Arduino.h>

int main(void)
     97c:	cf 93       	push	r28
     97e:	df 93       	push	r29
{
	init();
     980:	0e 94 92 02 	call	0x524	; 0x524 <init>

#if defined(USBCON)
	USBDevice.attach();
     984:	8f e9       	ldi	r24, 0x9F	; 159
     986:	91 e0       	ldi	r25, 0x01	; 1
     988:	0e 94 7e 06 	call	0xcfc	; 0xcfc <USBDevice_::attach()>
#endif
	
	setup();
     98c:	0e 94 e5 01 	call	0x3ca	; 0x3ca <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     990:	c0 e0       	ldi	r28, 0x00	; 0
     992:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
     994:	0e 94 9f 01 	call	0x33e	; 0x33e <loop>
		if (serialEventRun) serialEventRun();
     998:	20 97       	sbiw	r28, 0x00	; 0
     99a:	e1 f3       	breq	.-8      	; 0x994 <main+0x18>
     99c:	0e 94 00 00 	call	0	; 0x0 <__vectors>
     9a0:	f9 cf       	rjmp	.-14     	; 0x994 <main+0x18>

000009a2 <Print::write(unsigned char const*, unsigned int)>:
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
     9a2:	cf 92       	push	r12
     9a4:	df 92       	push	r13
     9a6:	ef 92       	push	r14
     9a8:	ff 92       	push	r15
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	7c 01       	movw	r14, r24
     9b4:	6b 01       	movw	r12, r22
     9b6:	8a 01       	movw	r16, r20
     9b8:	c0 e0       	ldi	r28, 0x00	; 0
     9ba:	d0 e0       	ldi	r29, 0x00	; 0
     9bc:	0f c0       	rjmp	.+30     	; 0x9dc <Print::write(unsigned char const*, unsigned int)+0x3a>
{
  size_t n = 0;
  while (size--) {
    n += write(*buffer++);
     9be:	d6 01       	movw	r26, r12
     9c0:	6d 91       	ld	r22, X+
     9c2:	6d 01       	movw	r12, r26
     9c4:	d7 01       	movw	r26, r14
     9c6:	ed 91       	ld	r30, X+
     9c8:	fc 91       	ld	r31, X
     9ca:	01 90       	ld	r0, Z+
     9cc:	f0 81       	ld	r31, Z
     9ce:	e0 2d       	mov	r30, r0
     9d0:	c7 01       	movw	r24, r14
     9d2:	09 95       	icall
     9d4:	c8 0f       	add	r28, r24
     9d6:	d9 1f       	adc	r29, r25
     9d8:	01 50       	subi	r16, 0x01	; 1
     9da:	10 40       	sbci	r17, 0x00	; 0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     9dc:	01 15       	cp	r16, r1
     9de:	11 05       	cpc	r17, r1
     9e0:	71 f7       	brne	.-36     	; 0x9be <Print::write(unsigned char const*, unsigned int)+0x1c>
    n += write(*buffer++);
  }
  return n;
}
     9e2:	ce 01       	movw	r24, r28
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	1f 91       	pop	r17
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	ef 90       	pop	r14
     9f0:	df 90       	pop	r13
     9f2:	cf 90       	pop	r12
     9f4:	08 95       	ret

000009f6 <Print::println()>:
size_t Print::print(const Printable& x)
{
  return x.printTo(*this);
}

size_t Print::println(void)
     9f6:	ef 92       	push	r14
     9f8:	ff 92       	push	r15
     9fa:	0f 93       	push	r16
     9fc:	1f 93       	push	r17
     9fe:	8c 01       	movw	r16, r24
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
     a00:	dc 01       	movw	r26, r24
     a02:	ed 91       	ld	r30, X+
     a04:	fc 91       	ld	r31, X
     a06:	01 90       	ld	r0, Z+
     a08:	f0 81       	ld	r31, Z
     a0a:	e0 2d       	mov	r30, r0
     a0c:	6d e0       	ldi	r22, 0x0D	; 13
     a0e:	09 95       	icall
     a10:	7c 01       	movw	r14, r24
size_t Print::println(void)
{
  size_t n = print('\r');
  n += print('\n');
  return n;
}
     a12:	d8 01       	movw	r26, r16
     a14:	ed 91       	ld	r30, X+
     a16:	fc 91       	ld	r31, X
     a18:	01 90       	ld	r0, Z+
     a1a:	f0 81       	ld	r31, Z
     a1c:	e0 2d       	mov	r30, r0
     a1e:	c8 01       	movw	r24, r16
     a20:	6a e0       	ldi	r22, 0x0A	; 10
     a22:	09 95       	icall
     a24:	9c 01       	movw	r18, r24
     a26:	2e 0d       	add	r18, r14
     a28:	3f 1d       	adc	r19, r15
     a2a:	c9 01       	movw	r24, r18
     a2c:	1f 91       	pop	r17
     a2e:	0f 91       	pop	r16
     a30:	ff 90       	pop	r15
     a32:	ef 90       	pop	r14
     a34:	08 95       	ret

00000a36 <Print::write(char const*)>:
     a36:	cf 93       	push	r28
     a38:	df 93       	push	r29
     a3a:	ec 01       	movw	r28, r24
     a3c:	61 15       	cp	r22, r1
     a3e:	71 05       	cpc	r23, r1
     a40:	19 f4       	brne	.+6      	; 0xa48 <Print::write(char const*)+0x12>
     a42:	20 e0       	ldi	r18, 0x00	; 0
     a44:	30 e0       	ldi	r19, 0x00	; 0
     a46:	0f c0       	rjmp	.+30     	; 0xa66 <Print::write(char const*)+0x30>
     a48:	db 01       	movw	r26, r22
     a4a:	0d 90       	ld	r0, X+
     a4c:	00 20       	and	r0, r0
     a4e:	e9 f7       	brne	.-6      	; 0xa4a <Print::write(char const*)+0x14>
     a50:	11 97       	sbiw	r26, 0x01	; 1
     a52:	a6 1b       	sub	r26, r22
     a54:	b7 0b       	sbc	r27, r23
     a56:	e8 81       	ld	r30, Y
     a58:	f9 81       	ldd	r31, Y+1	; 0x01
     a5a:	02 80       	ldd	r0, Z+2	; 0x02
     a5c:	f3 81       	ldd	r31, Z+3	; 0x03
     a5e:	e0 2d       	mov	r30, r0
     a60:	ad 01       	movw	r20, r26
     a62:	09 95       	icall
     a64:	9c 01       	movw	r18, r24
     a66:	c9 01       	movw	r24, r18
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	08 95       	ret

00000a6e <Print::printNumber(unsigned long, unsigned char)>:
  return n;
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
     a6e:	4f 92       	push	r4
     a70:	5f 92       	push	r5
     a72:	7f 92       	push	r7
     a74:	8f 92       	push	r8
     a76:	9f 92       	push	r9
     a78:	af 92       	push	r10
     a7a:	bf 92       	push	r11
     a7c:	cf 92       	push	r12
     a7e:	df 92       	push	r13
     a80:	ef 92       	push	r14
     a82:	ff 92       	push	r15
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	df 93       	push	r29
     a8a:	cf 93       	push	r28
     a8c:	cd b7       	in	r28, 0x3d	; 61
     a8e:	de b7       	in	r29, 0x3e	; 62
     a90:	a1 97       	sbiw	r28, 0x21	; 33
     a92:	0f b6       	in	r0, 0x3f	; 63
     a94:	f8 94       	cli
     a96:	de bf       	out	0x3e, r29	; 62
     a98:	0f be       	out	0x3f, r0	; 63
     a9a:	cd bf       	out	0x3d, r28	; 61
     a9c:	2c 01       	movw	r4, r24
     a9e:	74 2e       	mov	r7, r20
     aa0:	cb 01       	movw	r24, r22
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
     aa2:	22 30       	cpi	r18, 0x02	; 2
     aa4:	08 f4       	brcc	.+2      	; 0xaa8 <Print::printNumber(unsigned long, unsigned char)+0x3a>
     aa6:	2a e0       	ldi	r18, 0x0A	; 10

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
     aa8:	19 a2       	std	Y+33, r1	; 0x21
     aaa:	31 e2       	ldi	r19, 0x21	; 33
     aac:	c3 2e       	mov	r12, r19
     aae:	d1 2c       	mov	r13, r1
     ab0:	cc 0e       	add	r12, r28
     ab2:	dd 1e       	adc	r13, r29
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
     ab4:	82 2e       	mov	r8, r18
     ab6:	99 24       	eor	r9, r9
     ab8:	aa 24       	eor	r10, r10
     aba:	bb 24       	eor	r11, r11
     abc:	67 2d       	mov	r22, r7
     abe:	75 2f       	mov	r23, r21
     ac0:	a5 01       	movw	r20, r10
     ac2:	94 01       	movw	r18, r8
     ac4:	0e 94 75 0a 	call	0x14ea	; 0x14ea <__udivmodsi4>
     ac8:	79 01       	movw	r14, r18
     aca:	8a 01       	movw	r16, r20
    char c = m - base * n;
     acc:	c8 01       	movw	r24, r16
     ace:	b7 01       	movw	r22, r14
     ad0:	a5 01       	movw	r20, r10
     ad2:	94 01       	movw	r18, r8
     ad4:	0e 94 56 0a 	call	0x14ac	; 0x14ac <__mulsi3>
     ad8:	47 2d       	mov	r20, r7
     ada:	46 1b       	sub	r20, r22
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
     adc:	08 94       	sec
     ade:	c1 08       	sbc	r12, r1
     ae0:	d1 08       	sbc	r13, r1
     ae2:	4a 30       	cpi	r20, 0x0A	; 10
     ae4:	14 f4       	brge	.+4      	; 0xaea <Print::printNumber(unsigned long, unsigned char)+0x7c>
     ae6:	40 5d       	subi	r20, 0xD0	; 208
     ae8:	01 c0       	rjmp	.+2      	; 0xaec <Print::printNumber(unsigned long, unsigned char)+0x7e>
     aea:	49 5c       	subi	r20, 0xC9	; 201
     aec:	f6 01       	movw	r30, r12
     aee:	40 83       	st	Z, r20
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
     af0:	e1 14       	cp	r14, r1
     af2:	f1 04       	cpc	r15, r1
     af4:	01 05       	cpc	r16, r1
     af6:	11 05       	cpc	r17, r1
     af8:	21 f0       	breq	.+8      	; 0xb02 <__stack+0x3>
     afa:	7e 2c       	mov	r7, r14
     afc:	5f 2d       	mov	r21, r15
     afe:	c8 01       	movw	r24, r16
     b00:	dd cf       	rjmp	.-70     	; 0xabc <Print::printNumber(unsigned long, unsigned char)+0x4e>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
     b02:	c2 01       	movw	r24, r4
     b04:	b6 01       	movw	r22, r12
     b06:	0e 94 1b 05 	call	0xa36	; 0xa36 <Print::write(char const*)>
}
     b0a:	a1 96       	adiw	r28, 0x21	; 33
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	de bf       	out	0x3e, r29	; 62
     b12:	0f be       	out	0x3f, r0	; 63
     b14:	cd bf       	out	0x3d, r28	; 61
     b16:	cf 91       	pop	r28
     b18:	df 91       	pop	r29
     b1a:	1f 91       	pop	r17
     b1c:	0f 91       	pop	r16
     b1e:	ff 90       	pop	r15
     b20:	ef 90       	pop	r14
     b22:	df 90       	pop	r13
     b24:	cf 90       	pop	r12
     b26:	bf 90       	pop	r11
     b28:	af 90       	pop	r10
     b2a:	9f 90       	pop	r9
     b2c:	8f 90       	pop	r8
     b2e:	7f 90       	pop	r7
     b30:	5f 90       	pop	r5
     b32:	4f 90       	pop	r4
     b34:	08 95       	ret

00000b36 <Print::print(unsigned long, int)>:
  } else {
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
     b36:	dc 01       	movw	r26, r24
{
  if (base == 0) return write(n);
     b38:	21 15       	cp	r18, r1
     b3a:	31 05       	cpc	r19, r1
     b3c:	41 f4       	brne	.+16     	; 0xb4e <Print::print(unsigned long, int)+0x18>
     b3e:	ed 91       	ld	r30, X+
     b40:	fc 91       	ld	r31, X
     b42:	01 90       	ld	r0, Z+
     b44:	f0 81       	ld	r31, Z
     b46:	e0 2d       	mov	r30, r0
     b48:	64 2f       	mov	r22, r20
     b4a:	09 95       	icall
     b4c:	08 95       	ret
  else return printNumber(n, base);
     b4e:	0e 94 37 05 	call	0xa6e	; 0xa6e <Print::printNumber(unsigned long, unsigned char)>
}
     b52:	08 95       	ret

00000b54 <Print::println(unsigned int, int)>:
  size_t n = print(num, base);
  n += println();
  return n;
}

size_t Print::println(unsigned int num, int base)
     b54:	cf 92       	push	r12
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	6c 01       	movw	r12, r24
     b62:	7b 01       	movw	r14, r22
     b64:	9a 01       	movw	r18, r20
  return print((long) n, base);
}

size_t Print::print(unsigned int n, int base)
{
  return print((unsigned long) n, base);
     b66:	00 e0       	ldi	r16, 0x00	; 0
     b68:	10 e0       	ldi	r17, 0x00	; 0
     b6a:	b8 01       	movw	r22, r16
     b6c:	a7 01       	movw	r20, r14
     b6e:	0e 94 9b 05 	call	0xb36	; 0xb36 <Print::print(unsigned long, int)>
     b72:	8c 01       	movw	r16, r24
}

size_t Print::println(unsigned int num, int base)
{
  size_t n = print(num, base);
  n += println();
     b74:	c6 01       	movw	r24, r12
     b76:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <Print::println()>
     b7a:	08 0f       	add	r16, r24
     b7c:	19 1f       	adc	r17, r25
  return n;
}
     b7e:	c8 01       	movw	r24, r16
     b80:	1f 91       	pop	r17
     b82:	0f 91       	pop	r16
     b84:	ff 90       	pop	r15
     b86:	ef 90       	pop	r14
     b88:	df 90       	pop	r13
     b8a:	cf 90       	pop	r12
     b8c:	08 95       	ret

00000b8e <Print::print(char const*)>:
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
     b8e:	0e 94 1b 05 	call	0xa36	; 0xa36 <Print::write(char const*)>
}
     b92:	08 95       	ret

00000b94 <USB_Recv(unsigned char, void*, int)>:

//	Non Blocking receive
//	Return number of bytes read
int USB_Recv(u8 ep, void* d, int len)
     b94:	28 2f       	mov	r18, r24
{
	if (!_usbConfiguration || len < 0)
     b96:	80 91 99 01 	lds	r24, 0x0199
     b9a:	88 23       	and	r24, r24
     b9c:	c1 f0       	breq	.+48     	; 0xbce <USB_Recv(unsigned char, void*, int)+0x3a>
     b9e:	57 ff       	sbrs	r21, 7
     ba0:	1a c0       	rjmp	.+52     	; 0xbd6 <USB_Recv(unsigned char, void*, int)+0x42>
     ba2:	15 c0       	rjmp	.+42     	; 0xbce <USB_Recv(unsigned char, void*, int)+0x3a>
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
     ba4:	28 9a       	sbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;
     ba6:	90 93 98 01 	sts	0x0198, r25

	return UEDATX;	
     baa:	80 91 f1 00 	lds	r24, 0x00F1
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
     bae:	81 93       	st	Z+, r24
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
     bb0:	e2 17       	cp	r30, r18
     bb2:	f3 07       	cpc	r31, r19
     bb4:	b9 f7       	brne	.-18     	; 0xba4 <USB_Recv(unsigned char, void*, int)+0x10>
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
     bb6:	41 15       	cp	r20, r1
     bb8:	51 05       	cpc	r21, r1
     bba:	39 f0       	breq	.+14     	; 0xbca <USB_Recv(unsigned char, void*, int)+0x36>
	UENUM = ep;
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     bbc:	80 91 f2 00 	lds	r24, 0x00F2
	len = min(n,len);
	n = len;
	u8* dst = (u8*)d;
	while (n--)
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
     bc0:	88 23       	and	r24, r24
     bc2:	19 f4       	brne	.+6      	; 0xbca <USB_Recv(unsigned char, void*, int)+0x36>
	return UEINTX & (1<<FIFOCON);
}

static inline void ReleaseRX()
{
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
     bc4:	8b e6       	ldi	r24, 0x6B	; 107
     bc6:	80 93 e8 00 	sts	0x00E8, r24
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     bca:	af bf       	out	0x3f, r26	; 63
     bcc:	02 c0       	rjmp	.+4      	; 0xbd2 <USB_Recv(unsigned char, void*, int)+0x3e>
     bce:	4f ef       	ldi	r20, 0xFF	; 255
     bd0:	5f ef       	ldi	r21, 0xFF	; 255
		*dst++ = Recv8();
	if (len && !FifoByteCount())	// release empty buffer
		ReleaseRX();
	
	return len;
}
     bd2:	ca 01       	movw	r24, r20
     bd4:	08 95       	ret
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     bd6:	af b7       	in	r26, 0x3f	; 63
	{
		cli();
     bd8:	f8 94       	cli
		SetEP(ep & 7);
     bda:	27 70       	andi	r18, 0x07	; 7
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     bdc:	20 93 e9 00 	sts	0x00E9, r18
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     be0:	80 91 f2 00 	lds	r24, 0x00F2
	if (!_usbConfiguration || len < 0)
		return -1;
	
	LockEP lock(ep);
	u8 n = FifoByteCount();
	len = min(n,len);
     be4:	28 2f       	mov	r18, r24
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	24 17       	cp	r18, r20
     bea:	35 07       	cpc	r19, r21
     bec:	0c f4       	brge	.+2      	; 0xbf0 <USB_Recv(unsigned char, void*, int)+0x5c>
     bee:	a9 01       	movw	r20, r18
	n = len;
	u8* dst = (u8*)d;
     bf0:	fb 01       	movw	r30, r22
	while (n--)
     bf2:	9b 01       	movw	r18, r22
     bf4:	24 0f       	add	r18, r20
     bf6:	31 1d       	adc	r19, r1
}

static inline u8 Recv8()
{
	RXLED1;					// light the RX LED
	RxLEDPulse = TX_RX_LED_PULSE_MS;
     bf8:	94 e6       	ldi	r25, 0x64	; 100
     bfa:	da cf       	rjmp	.-76     	; 0xbb0 <USB_Recv(unsigned char, void*, int)+0x1c>

00000bfc <USB_Recv(unsigned char)>:
	
	return len;
}

//	Recv 1 byte if ready
int USB_Recv(u8 ep)
     bfc:	df 93       	push	r29
     bfe:	cf 93       	push	r28
     c00:	0f 92       	push	r0
     c02:	cd b7       	in	r28, 0x3d	; 61
     c04:	de b7       	in	r29, 0x3e	; 62
{
	u8 c;
	if (USB_Recv(ep,&c,1) != 1)
     c06:	be 01       	movw	r22, r28
     c08:	6f 5f       	subi	r22, 0xFF	; 255
     c0a:	7f 4f       	sbci	r23, 0xFF	; 255
     c0c:	41 e0       	ldi	r20, 0x01	; 1
     c0e:	50 e0       	ldi	r21, 0x00	; 0
     c10:	0e 94 ca 05 	call	0xb94	; 0xb94 <USB_Recv(unsigned char, void*, int)>
     c14:	01 97       	sbiw	r24, 0x01	; 1
     c16:	19 f0       	breq	.+6      	; 0xc1e <USB_Recv(unsigned char)+0x22>
     c18:	2f ef       	ldi	r18, 0xFF	; 255
     c1a:	3f ef       	ldi	r19, 0xFF	; 255
     c1c:	03 c0       	rjmp	.+6      	; 0xc24 <USB_Recv(unsigned char)+0x28>
		return -1;
	return c;
     c1e:	89 81       	ldd	r24, Y+1	; 0x01
     c20:	28 2f       	mov	r18, r24
     c22:	30 e0       	ldi	r19, 0x00	; 0
}
     c24:	c9 01       	movw	r24, r18
     c26:	0f 90       	pop	r0
     c28:	cf 91       	pop	r28
     c2a:	df 91       	pop	r29
     c2c:	08 95       	ret

00000c2e <USB_SendControl(unsigned char, void const*, int)>:
	_cmark++;
	return true;
};

//	Clipped by _cmark/_cend
int USB_SendControl(u8 flags, const void* d, int len)
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	f8 2e       	mov	r15, r24
     c36:	14 2f       	mov	r17, r20
     c38:	05 2f       	mov	r16, r21
}

static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
     c3a:	40 91 9c 01 	lds	r20, 0x019C
     c3e:	50 91 9d 01 	lds	r21, 0x019D
     c42:	21 2f       	mov	r18, r17
     c44:	30 2f       	mov	r19, r16
     c46:	c9 01       	movw	r24, r18
     c48:	dc 01       	movw	r26, r24
     c4a:	fb 01       	movw	r30, r22
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
     c4c:	6e ef       	ldi	r22, 0xFE	; 254
     c4e:	29 c0       	rjmp	.+82     	; 0xca2 <USB_SendControl(unsigned char, void const*, int)+0x74>
	int sent = len;
	const u8* data = (const u8*)d;
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
	{
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
     c50:	f7 fe       	sbrs	r15, 7
     c52:	02 c0       	rjmp	.+4      	; 0xc58 <USB_SendControl(unsigned char, void const*, int)+0x2a>
     c54:	94 91       	lpm	r25, Z+
     c56:	01 c0       	rjmp	.+2      	; 0xc5a <USB_SendControl(unsigned char, void const*, int)+0x2c>
     c58:	90 81       	ld	r25, Z
}

static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
     c5a:	20 91 9a 01 	lds	r18, 0x019A
     c5e:	30 91 9b 01 	lds	r19, 0x019B
     c62:	24 17       	cp	r18, r20
     c64:	35 07       	cpc	r19, r21
     c66:	ac f4       	brge	.+42     	; 0xc92 <USB_SendControl(unsigned char, void const*, int)+0x64>
		;
}

static inline u8 WaitForINOrOUT()
{
	while (!(UEINTX & ((1<<TXINI)|(1<<RXOUTI))))
     c68:	80 91 e8 00 	lds	r24, 0x00E8
     c6c:	85 70       	andi	r24, 0x05	; 5
     c6e:	e1 f3       	breq	.-8      	; 0xc68 <USB_SendControl(unsigned char, void const*, int)+0x3a>
		;
	return (UEINTX & (1<<RXOUTI)) == 0;
     c70:	80 91 e8 00 	lds	r24, 0x00E8
static
bool SendControl(u8 d)
{
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
     c74:	82 ff       	sbrs	r24, 2
     c76:	03 c0       	rjmp	.+6      	; 0xc7e <USB_SendControl(unsigned char, void const*, int)+0x50>
     c78:	2f ef       	ldi	r18, 0xFF	; 255
     c7a:	3f ef       	ldi	r19, 0xFF	; 255
     c7c:	17 c0       	rjmp	.+46     	; 0xcac <USB_SendControl(unsigned char, void const*, int)+0x7e>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     c7e:	90 93 f1 00 	sts	0x00F1, r25
	if (_cmark < _cend)
	{
		if (!WaitForINOrOUT())
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
     c82:	c9 01       	movw	r24, r18
     c84:	01 96       	adiw	r24, 0x01	; 1
     c86:	8f 73       	andi	r24, 0x3F	; 63
     c88:	90 70       	andi	r25, 0x00	; 0
     c8a:	89 2b       	or	r24, r25
     c8c:	11 f4       	brne	.+4      	; 0xc92 <USB_SendControl(unsigned char, void const*, int)+0x64>
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
     c8e:	60 93 e8 00 	sts	0x00E8, r22
			return false;
		Send8(d);
		if (!((_cmark + 1) & 0x3F))
			ClearIN();	// Fifo is full, release this packet
	}
	_cmark++;
     c92:	2f 5f       	subi	r18, 0xFF	; 255
     c94:	3f 4f       	sbci	r19, 0xFF	; 255
     c96:	30 93 9b 01 	sts	0x019B, r19
     c9a:	20 93 9a 01 	sts	0x019A, r18
     c9e:	11 97       	sbiw	r26, 0x01	; 1
     ca0:	31 96       	adiw	r30, 0x01	; 1
int USB_SendControl(u8 flags, const void* d, int len)
{
	int sent = len;
	const u8* data = (const u8*)d;
	bool pgm = flags & TRANSFER_PGM;
	while (len--)
     ca2:	10 97       	sbiw	r26, 0x00	; 0
     ca4:	a9 f6       	brne	.-86     	; 0xc50 <USB_SendControl(unsigned char, void const*, int)+0x22>
     ca6:	81 2f       	mov	r24, r17
     ca8:	90 2f       	mov	r25, r16
     caa:	9c 01       	movw	r18, r24
		u8 c = pgm ? pgm_read_byte(data++) : *data++;
		if (!SendControl(c))
			return -1;
	}
	return sent;
}
     cac:	c9 01       	movw	r24, r18
     cae:	1f 91       	pop	r17
     cb0:	0f 91       	pop	r16
     cb2:	ff 90       	pop	r15
     cb4:	08 95       	ret

00000cb6 <USB_RecvControl(void*, int)>:

//	Does not timeout or cross fifo boundaries
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
     cb6:	9c 01       	movw	r18, r24
	UEINTX = ~(1<<TXINI);
}

static inline void WaitOUT(void)
{
	while (!(UEINTX & (1<<RXOUTI)))
     cb8:	80 91 e8 00 	lds	r24, 0x00E8
     cbc:	82 ff       	sbrs	r24, 2
     cbe:	fc cf       	rjmp	.-8      	; 0xcb8 <USB_RecvControl(void*, int)+0x2>
//	Will only work for transfers <= 64 bytes
//	TODO
int USB_RecvControl(void* d, int len)
{
	WaitOUT();
	Recv((u8*)d,len);
     cc0:	f9 01       	movw	r30, r18
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
	while (count--)
     cc2:	26 0f       	add	r18, r22
     cc4:	31 1d       	adc	r19, r1
     cc6:	03 c0       	rjmp	.+6      	; 0xcce <USB_RecvControl(void*, int)+0x18>
		*data++ = UEDATX;
     cc8:	80 91 f1 00 	lds	r24, 0x00F1
     ccc:	81 93       	st	Z+, r24
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
	while (count--)
     cce:	e2 17       	cp	r30, r18
     cd0:	f3 07       	cpc	r31, r19
     cd2:	d1 f7       	brne	.-12     	; 0xcc8 <USB_RecvControl(void*, int)+0x12>
		*data++ = UEDATX;
	
	RXLED1;					// light the RX LED
     cd4:	28 9a       	sbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
     cd6:	84 e6       	ldi	r24, 0x64	; 100
     cd8:	80 93 98 01 	sts	0x0198, r24
	return (UEINTX & (1<<RXOUTI)) == 0;
}

static inline void ClearOUT(void)
{
	UEINTX = ~(1<<RXOUTI);
     cdc:	8b ef       	ldi	r24, 0xFB	; 251
     cde:	80 93 e8 00 	sts	0x00E8, r24
{
	WaitOUT();
	Recv((u8*)d,len);
	ClearOUT();
	return len;
}
     ce2:	cb 01       	movw	r24, r22
     ce4:	08 95       	ret

00000ce6 <USB_Flush(unsigned char)>:
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     ce6:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     cea:	80 91 f2 00 	lds	r24, 0x00F2
}

void USB_Flush(u8 ep)
{
	SetEP(ep);
	if (FifoByteCount())
     cee:	88 23       	and	r24, r24
     cf0:	19 f0       	breq	.+6      	; 0xcf8 <USB_Flush(unsigned char)+0x12>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
     cf2:	8a e3       	ldi	r24, 0x3A	; 58
     cf4:	80 93 e8 00 	sts	0x00E8, r24
     cf8:	08 95       	ret

00000cfa <global constructors keyed to TxLEDPulse>:
	return _usbConfiguration;
}

void USBDevice_::poll()
{
}
     cfa:	08 95       	ret

00000cfc <USBDevice_::attach()>:
{
}

void USBDevice_::attach()
{
	_usbConfiguration = 0;
     cfc:	10 92 99 01 	sts	0x0199, r1
	UHWCON = 0x01;						// power internal reg
     d00:	81 e0       	ldi	r24, 0x01	; 1
     d02:	80 93 d7 00 	sts	0x00D7, r24
	USBCON = (1<<USBE)|(1<<FRZCLK);		// clock frozen, usb enabled
     d06:	80 ea       	ldi	r24, 0xA0	; 160
     d08:	80 93 d8 00 	sts	0x00D8, r24
#if F_CPU == 16000000UL
	PLLCSR = 0x12;						// Need 16 MHz xtal
     d0c:	82 e1       	ldi	r24, 0x12	; 18
     d0e:	89 bd       	out	0x29, r24	; 41
#elif F_CPU == 8000000UL
	PLLCSR = 0x02;						// Need 8 MHz xtal
#endif
	while (!(PLLCSR & (1<<PLOCK)))		// wait for lock pll
     d10:	09 b4       	in	r0, 0x29	; 41
     d12:	00 fe       	sbrs	r0, 0
     d14:	fd cf       	rjmp	.-6      	; 0xd10 <USBDevice_::attach()+0x14>
		;

	// Some tests on specific versions of macosx (10.7.3), reported some
	// strange behaviuors when the board is reset using the serial
	// port touch at 1200 bps. This delay fixes this behaviour.
	delay(1);
     d16:	61 e0       	ldi	r22, 0x01	; 1
     d18:	70 e0       	ldi	r23, 0x00	; 0
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	0e 94 39 02 	call	0x472	; 0x472 <delay>

	USBCON = ((1<<USBE)|(1<<OTGPADE));	// start USB clock
     d22:	80 e9       	ldi	r24, 0x90	; 144
     d24:	80 93 d8 00 	sts	0x00D8, r24
	UDIEN = (1<<EORSTE)|(1<<SOFE);		// Enable interrupts for EOR (End of Reset) and SOF (start of frame)
     d28:	8c e0       	ldi	r24, 0x0C	; 12
     d2a:	80 93 e2 00 	sts	0x00E2, r24
	UDCON = 0;							// enable attach resistor
     d2e:	10 92 e0 00 	sts	0x00E0, r1
	
	TX_RX_LED_INIT;
     d32:	55 9a       	sbi	0x0a, 5	; 10
     d34:	20 9a       	sbi	0x04, 0	; 4
     d36:	5d 98       	cbi	0x0b, 5	; 11
     d38:	28 98       	cbi	0x05, 0	; 5
}
     d3a:	08 95       	ret

00000d3c <USB_Send(unsigned char, void const*, int)>:
		return 0;
	return 64 - FifoByteCount();
}

//	Blocking Send of data to an endpoint
int USB_Send(u8 ep, const void* d, int len)
     d3c:	5f 92       	push	r5
     d3e:	6f 92       	push	r6
     d40:	7f 92       	push	r7
     d42:	8f 92       	push	r8
     d44:	9f 92       	push	r9
     d46:	af 92       	push	r10
     d48:	bf 92       	push	r11
     d4a:	cf 92       	push	r12
     d4c:	df 92       	push	r13
     d4e:	ef 92       	push	r14
     d50:	ff 92       	push	r15
     d52:	0f 93       	push	r16
     d54:	1f 93       	push	r17
     d56:	cf 93       	push	r28
     d58:	df 93       	push	r29
     d5a:	e8 2e       	mov	r14, r24
     d5c:	84 2e       	mov	r8, r20
     d5e:	75 2e       	mov	r7, r21
{
	if (!_usbConfiguration)
     d60:	80 91 99 01 	lds	r24, 0x0199
     d64:	88 23       	and	r24, r24
     d66:	71 f1       	breq	.+92     	; 0xdc4 <USB_Send(unsigned char, void const*, int)+0x88>
		return -1;

	int r = len;
	const u8* data = (const u8*)d;
     d68:	8b 01       	movw	r16, r22
     d6a:	24 2f       	mov	r18, r20
     d6c:	35 2f       	mov	r19, r21
     d6e:	c9 01       	movw	r24, r18
     d70:	ec 01       	movw	r28, r24
     d72:	7a ef       	ldi	r23, 0xFA	; 250
     d74:	f7 2e       	mov	r15, r23
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
	{
		cli();
		SetEP(ep & 7);
     d76:	67 e0       	ldi	r22, 0x07	; 7
     d78:	96 2e       	mov	r9, r22
     d7a:	9e 20       	and	r9, r14
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
     d7c:	50 e4       	ldi	r21, 0x40	; 64
     d7e:	55 2e       	mov	r5, r21
		if (n > len)
			n = len;
		len -= n;
		{
			LockEP lock(ep);
			if (ep & TRANSFER_ZERO)
     d80:	8e 2d       	mov	r24, r14
     d82:	90 e0       	ldi	r25, 0x00	; 0
     d84:	40 e2       	ldi	r20, 0x20	; 32
     d86:	a4 2e       	mov	r10, r20
     d88:	b1 2c       	mov	r11, r1
     d8a:	a8 22       	and	r10, r24
     d8c:	b9 22       	and	r11, r25
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
     d8e:	3a e3       	ldi	r19, 0x3A	; 58
     d90:	63 2e       	mov	r6, r19
			else
			{
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
     d92:	20 e4       	ldi	r18, 0x40	; 64
     d94:	c2 2e       	mov	r12, r18
     d96:	d1 2c       	mov	r13, r1
     d98:	c8 22       	and	r12, r24
     d9a:	d9 22       	and	r13, r25
     d9c:	58 c0       	rjmp	.+176    	; 0xe4e <USB_Send(unsigned char, void const*, int)+0x112>
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     d9e:	9f b7       	in	r25, 0x3f	; 63
	{
		cli();
     da0:	f8 94       	cli
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     da2:	90 92 e9 00 	sts	0x00E9, r9
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     da6:	80 91 e8 00 	lds	r24, 0x00E8

//	Space in send EP
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
     daa:	85 fd       	sbrc	r24, 5
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <USB_Send(unsigned char, void const*, int)+0x76>
     dae:	20 e0       	ldi	r18, 0x00	; 0
     db0:	04 c0       	rjmp	.+8      	; 0xdba <USB_Send(unsigned char, void const*, int)+0x7e>
	UENUM = ep;
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     db2:	80 91 f2 00 	lds	r24, 0x00F2
u8 USB_SendSpace(u8 ep)
{
	LockEP lock(ep);
	if (!ReadWriteAllowed())
		return 0;
	return 64 - FifoByteCount();
     db6:	25 2d       	mov	r18, r5
     db8:	28 1b       	sub	r18, r24
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     dba:	9f bf       	out	0x3f, r25	; 63
	u8 zero = ep & TRANSFER_ZERO;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
	{
		u8 n = USB_SendSpace(ep);
		if (n == 0)
     dbc:	22 23       	and	r18, r18
     dbe:	61 f4       	brne	.+24     	; 0xdd8 <USB_Send(unsigned char, void const*, int)+0x9c>
		{
			if (!(--timeout))
     dc0:	fa 94       	dec	r15
     dc2:	19 f4       	brne	.+6      	; 0xdca <USB_Send(unsigned char, void const*, int)+0x8e>
     dc4:	2f ef       	ldi	r18, 0xFF	; 255
     dc6:	3f ef       	ldi	r19, 0xFF	; 255
     dc8:	4d c0       	rjmp	.+154    	; 0xe64 <USB_Send(unsigned char, void const*, int)+0x128>
				return -1;
			delay(1);
     dca:	61 e0       	ldi	r22, 0x01	; 1
     dcc:	70 e0       	ldi	r23, 0x00	; 0
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	0e 94 39 02 	call	0x472	; 0x472 <delay>
     dd6:	3b c0       	rjmp	.+118    	; 0xe4e <USB_Send(unsigned char, void const*, int)+0x112>
			continue;
		}

		if (n > len)
     dd8:	82 2f       	mov	r24, r18
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	c8 17       	cp	r28, r24
     dde:	d9 07       	cpc	r29, r25
     de0:	0c f4       	brge	.+2      	; 0xde4 <USB_Send(unsigned char, void const*, int)+0xa8>
			n = len;
     de2:	2c 2f       	mov	r18, r28
		len -= n;
     de4:	c2 1b       	sub	r28, r18
     de6:	d1 09       	sbc	r29, r1
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     de8:	4f b7       	in	r20, 0x3f	; 63
	{
		cli();
     dea:	f8 94       	cli
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     dec:	90 92 e9 00 	sts	0x00E9, r9
		if (n > len)
			n = len;
		len -= n;
		{
			LockEP lock(ep);
			if (ep & TRANSFER_ZERO)
     df0:	a1 14       	cp	r10, r1
     df2:	b1 04       	cpc	r11, r1
     df4:	21 f4       	brne	.+8      	; 0xdfe <USB_Send(unsigned char, void const*, int)+0xc2>
     df6:	06 c0       	rjmp	.+12     	; 0xe04 <USB_Send(unsigned char, void const*, int)+0xc8>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     df8:	10 92 f1 00 	sts	0x00F1, r1
     dfc:	21 50       	subi	r18, 0x01	; 1
		len -= n;
		{
			LockEP lock(ep);
			if (ep & TRANSFER_ZERO)
			{
				while (n--)
     dfe:	22 23       	and	r18, r18
     e00:	d9 f7       	brne	.-10     	; 0xdf8 <USB_Send(unsigned char, void const*, int)+0xbc>
     e02:	19 c0       	rjmp	.+50     	; 0xe36 <USB_Send(unsigned char, void const*, int)+0xfa>
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
     e04:	e7 fc       	sbrc	r14, 7
     e06:	03 c0       	rjmp	.+6      	; 0xe0e <USB_Send(unsigned char, void const*, int)+0xd2>
     e08:	f8 01       	movw	r30, r16
     e0a:	92 2f       	mov	r25, r18
     e0c:	10 c0       	rjmp	.+32     	; 0xe2e <USB_Send(unsigned char, void const*, int)+0xf2>
     e0e:	c8 01       	movw	r24, r16
     e10:	32 2f       	mov	r19, r18
     e12:	06 c0       	rjmp	.+12     	; 0xe20 <USB_Send(unsigned char, void const*, int)+0xe4>
     e14:	fc 01       	movw	r30, r24
			{
				while (n--)
					Send8(pgm_read_byte(data++));
     e16:	01 96       	adiw	r24, 0x01	; 1
     e18:	e4 91       	lpm	r30, Z+
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     e1a:	e0 93 f1 00 	sts	0x00F1, r30
     e1e:	31 50       	subi	r19, 0x01	; 1
				while (n--)
					Send8(0);
			}
			else if (ep & TRANSFER_PGM)
			{
				while (n--)
     e20:	33 23       	and	r19, r19
     e22:	c1 f7       	brne	.-16     	; 0xe14 <USB_Send(unsigned char, void const*, int)+0xd8>
     e24:	06 c0       	rjmp	.+12     	; 0xe32 <USB_Send(unsigned char, void const*, int)+0xf6>
					Send8(pgm_read_byte(data++));
			}
			else
			{
				while (n--)
					Send8(*data++);
     e26:	81 91       	ld	r24, Z+
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
     e28:	80 93 f1 00 	sts	0x00F1, r24
     e2c:	91 50       	subi	r25, 0x01	; 1
				while (n--)
					Send8(pgm_read_byte(data++));
			}
			else
			{
				while (n--)
     e2e:	99 23       	and	r25, r25
     e30:	d1 f7       	brne	.-12     	; 0xe26 <USB_Send(unsigned char, void const*, int)+0xea>
     e32:	02 0f       	add	r16, r18
     e34:	11 1d       	adc	r17, r1
	UECONX = (1<<STALLRQ) | (1<<EPEN);
}

static inline u8 ReadWriteAllowed()
{
	return UEINTX & (1<<RWAL);
     e36:	80 91 e8 00 	lds	r24, 0x00E8
			else
			{
				while (n--)
					Send8(*data++);
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
     e3a:	85 ff       	sbrs	r24, 5
     e3c:	05 c0       	rjmp	.+10     	; 0xe48 <USB_Send(unsigned char, void const*, int)+0x10c>
     e3e:	20 97       	sbiw	r28, 0x00	; 0
     e40:	29 f4       	brne	.+10     	; 0xe4c <USB_Send(unsigned char, void const*, int)+0x110>
     e42:	c1 14       	cp	r12, r1
     e44:	d1 04       	cpc	r13, r1
     e46:	11 f0       	breq	.+4      	; 0xe4c <USB_Send(unsigned char, void const*, int)+0x110>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
     e48:	60 92 e8 00 	sts	0x00E8, r6
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     e4c:	4f bf       	out	0x3f, r20	; 63

	int r = len;
	const u8* data = (const u8*)d;
	u8 zero = ep & TRANSFER_ZERO;
	u8 timeout = 250;		// 250ms timeout on send? TODO
	while (len)
     e4e:	20 97       	sbiw	r28, 0x00	; 0
     e50:	09 f0       	breq	.+2      	; 0xe54 <USB_Send(unsigned char, void const*, int)+0x118>
     e52:	a5 cf       	rjmp	.-182    	; 0xd9e <USB_Send(unsigned char, void const*, int)+0x62>
			}
			if (!ReadWriteAllowed() || ((len == 0) && (ep & TRANSFER_RELEASE)))	// Release full buffer
				ReleaseTX();
		}
	}
	TXLED1;					// light the TX LED
     e54:	5d 9a       	sbi	0x0b, 5	; 11
	TxLEDPulse = TX_RX_LED_PULSE_MS;
     e56:	84 e6       	ldi	r24, 0x64	; 100
     e58:	80 93 97 01 	sts	0x0197, r24
     e5c:	28 2d       	mov	r18, r8
     e5e:	37 2d       	mov	r19, r7
     e60:	c9 01       	movw	r24, r18
     e62:	9c 01       	movw	r18, r24
	return r;
}
     e64:	c9 01       	movw	r24, r18
     e66:	df 91       	pop	r29
     e68:	cf 91       	pop	r28
     e6a:	1f 91       	pop	r17
     e6c:	0f 91       	pop	r16
     e6e:	ff 90       	pop	r15
     e70:	ef 90       	pop	r14
     e72:	df 90       	pop	r13
     e74:	cf 90       	pop	r12
     e76:	bf 90       	pop	r11
     e78:	af 90       	pop	r10
     e7a:	9f 90       	pop	r9
     e7c:	8f 90       	pop	r8
     e7e:	7f 90       	pop	r7
     e80:	6f 90       	pop	r6
     e82:	5f 90       	pop	r5
     e84:	08 95       	ret

00000e86 <__vector_10>:
	if (FifoByteCount())
		ReleaseTX();
}

//	General interrupt
ISR(USB_GEN_vect)
     e86:	1f 92       	push	r1
     e88:	0f 92       	push	r0
     e8a:	0f b6       	in	r0, 0x3f	; 63
     e8c:	0f 92       	push	r0
     e8e:	11 24       	eor	r1, r1
     e90:	2f 93       	push	r18
     e92:	3f 93       	push	r19
     e94:	4f 93       	push	r20
     e96:	5f 93       	push	r21
     e98:	6f 93       	push	r22
     e9a:	7f 93       	push	r23
     e9c:	8f 93       	push	r24
     e9e:	9f 93       	push	r25
     ea0:	af 93       	push	r26
     ea2:	bf 93       	push	r27
     ea4:	ef 93       	push	r30
     ea6:	ff 93       	push	r31
{
	u8 udint = UDINT;
     ea8:	80 91 e1 00 	lds	r24, 0x00E1
	UDINT = 0;
     eac:	10 92 e1 00 	sts	0x00E1, r1

	//	End of Reset
	if (udint & (1<<EORSTI))
     eb0:	98 2f       	mov	r25, r24
     eb2:	83 ff       	sbrs	r24, 3
     eb4:	0f c0       	rjmp	.+30     	; 0xed4 <__vector_10+0x4e>
#define EP_DOUBLE_64 0x36	// Other endpoints

static
void InitEP(u8 index, u8 type, u8 size)
{
	UENUM = index;
     eb6:	10 92 e9 00 	sts	0x00E9, r1
	UECONX = 1;
     eba:	81 e0       	ldi	r24, 0x01	; 1
     ebc:	80 93 eb 00 	sts	0x00EB, r24
	UECFG0X = type;
     ec0:	10 92 ec 00 	sts	0x00EC, r1
	UECFG1X = size;
     ec4:	82 e3       	ldi	r24, 0x32	; 50
     ec6:	80 93 ed 00 	sts	0x00ED, r24

	//	End of Reset
	if (udint & (1<<EORSTI))
	{
		InitEP(0,EP_TYPE_CONTROL,EP_SINGLE_64);	// init ep0
		_usbConfiguration = 0;			// not configured yet
     eca:	10 92 99 01 	sts	0x0199, r1
		UEIENX = 1 << RXSTPE;			// Enable interrupts for ep0
     ece:	88 e0       	ldi	r24, 0x08	; 8
     ed0:	80 93 f0 00 	sts	0x00F0, r24
	}

	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
     ed4:	92 ff       	sbrs	r25, 2
     ed6:	34 c0       	rjmp	.+104    	; 0xf40 <__vector_10+0xba>
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     ed8:	83 e0       	ldi	r24, 0x03	; 3
     eda:	80 93 e9 00 	sts	0x00E9, r24
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     ede:	80 91 f2 00 	lds	r24, 0x00F2
}

void USB_Flush(u8 ep)
{
	SetEP(ep);
	if (FifoByteCount())
     ee2:	88 23       	and	r24, r24
     ee4:	19 f0       	breq	.+6      	; 0xeec <__vector_10+0x66>
	UEINTX = 0x6B;	// FIFOCON=0 NAKINI=1 RWAL=1 NAKOUTI=0 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=1
}

static inline void ReleaseTX()
{
	UEINTX = 0x3A;	// FIFOCON=0 NAKINI=0 RWAL=1 NAKOUTI=1 RXSTPI=1 RXOUTI=0 STALLEDI=1 TXINI=0
     ee6:	8a e3       	ldi	r24, 0x3A	; 58
     ee8:	80 93 e8 00 	sts	0x00E8, r24
#define USB_RECV_TIMEOUT
class LockEP
{
	u8 _sreg;
public:
	LockEP(u8 ep) : _sreg(SREG)
     eec:	8f b7       	in	r24, 0x3f	; 63
	{
		cli();
     eee:	f8 94       	cli
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     ef0:	92 e0       	ldi	r25, 0x02	; 2
     ef2:	90 93 e9 00 	sts	0x00E9, r25
}

static inline u8 FifoByteCount()
{
	return UEBCLX;
     ef6:	90 91 f2 00 	lds	r25, 0x00F2
		cli();
		SetEP(ep & 7);
	}
	~LockEP()
	{
		SREG = _sreg;
     efa:	8f bf       	out	0x3f, r24	; 63
	//	Start of Frame - happens every millisecond so we use it for TX and RX LED one-shot timing, too
	if (udint & (1<<SOFI))
	{
#ifdef CDC_ENABLED
		USB_Flush(CDC_TX);				// Send a tx frame if found
		if (USB_Available(CDC_RX))	// Handle received bytes (if any)
     efc:	99 23       	and	r25, r25
     efe:	21 f0       	breq	.+8      	; 0xf08 <__vector_10+0x82>
			Serial.accept();
     f00:	89 e8       	ldi	r24, 0x89	; 137
     f02:	91 e0       	ldi	r25, 0x01	; 1
     f04:	0e 94 36 04 	call	0x86c	; 0x86c <Serial_::accept()>
#endif
		
		// check whether the one-shot period has elapsed.  if so, turn off the LED
		if (TxLEDPulse && !(--TxLEDPulse))
     f08:	80 91 97 01 	lds	r24, 0x0197
     f0c:	88 23       	and	r24, r24
     f0e:	51 f0       	breq	.+20     	; 0xf24 <__vector_10+0x9e>
     f10:	80 91 97 01 	lds	r24, 0x0197
     f14:	81 50       	subi	r24, 0x01	; 1
     f16:	80 93 97 01 	sts	0x0197, r24
     f1a:	80 91 97 01 	lds	r24, 0x0197
     f1e:	88 23       	and	r24, r24
     f20:	09 f4       	brne	.+2      	; 0xf24 <__vector_10+0x9e>
			TXLED0;
     f22:	5d 98       	cbi	0x0b, 5	; 11
		if (RxLEDPulse && !(--RxLEDPulse))
     f24:	80 91 98 01 	lds	r24, 0x0198
     f28:	88 23       	and	r24, r24
     f2a:	51 f0       	breq	.+20     	; 0xf40 <__vector_10+0xba>
     f2c:	80 91 98 01 	lds	r24, 0x0198
     f30:	81 50       	subi	r24, 0x01	; 1
     f32:	80 93 98 01 	sts	0x0198, r24
     f36:	80 91 98 01 	lds	r24, 0x0198
     f3a:	88 23       	and	r24, r24
     f3c:	09 f4       	brne	.+2      	; 0xf40 <__vector_10+0xba>
			RXLED0;
     f3e:	28 98       	cbi	0x05, 0	; 5
	}
}
     f40:	ff 91       	pop	r31
     f42:	ef 91       	pop	r30
     f44:	bf 91       	pop	r27
     f46:	af 91       	pop	r26
     f48:	9f 91       	pop	r25
     f4a:	8f 91       	pop	r24
     f4c:	7f 91       	pop	r23
     f4e:	6f 91       	pop	r22
     f50:	5f 91       	pop	r21
     f52:	4f 91       	pop	r20
     f54:	3f 91       	pop	r19
     f56:	2f 91       	pop	r18
     f58:	0f 90       	pop	r0
     f5a:	0f be       	out	0x3f, r0	; 63
     f5c:	0f 90       	pop	r0
     f5e:	1f 90       	pop	r1
     f60:	18 95       	reti

00000f62 <SendInterfaces()>:
	Recv((u8*)d,len);
	ClearOUT();
	return len;
}

int SendInterfaces()
     f62:	0f 93       	push	r16
     f64:	1f 93       	push	r17
     f66:	df 93       	push	r29
     f68:	cf 93       	push	r28
     f6a:	0f 92       	push	r0
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
{
	int total = 0;
	u8 interfaces = 0;
     f70:	19 82       	std	Y+1, r1	; 0x01

#ifdef CDC_ENABLED
	total = CDC_GetInterface(&interfaces);
     f72:	8e 01       	movw	r16, r28
     f74:	0f 5f       	subi	r16, 0xFF	; 255
     f76:	1f 4f       	sbci	r17, 0xFF	; 255
     f78:	c8 01       	movw	r24, r16
     f7a:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <CDC_GetInterface(unsigned char*)>
#endif

#ifdef HID_ENABLED
	total += HID_GetInterface(&interfaces);
     f7e:	c8 01       	movw	r24, r16
     f80:	0e 94 4a 0a 	call	0x1494	; 0x1494 <HID_GetInterface(unsigned char*)>
#endif

	return interfaces;
}
     f84:	89 81       	ldd	r24, Y+1	; 0x01
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	0f 90       	pop	r0
     f8a:	cf 91       	pop	r28
     f8c:	df 91       	pop	r29
     f8e:	1f 91       	pop	r17
     f90:	0f 91       	pop	r16
     f92:	08 95       	ret

00000f94 <__vector_11>:
	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
	return true;
}

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
     f94:	1f 92       	push	r1
     f96:	0f 92       	push	r0
     f98:	0f b6       	in	r0, 0x3f	; 63
     f9a:	0f 92       	push	r0
     f9c:	11 24       	eor	r1, r1
     f9e:	ef 92       	push	r14
     fa0:	ff 92       	push	r15
     fa2:	1f 93       	push	r17
     fa4:	2f 93       	push	r18
     fa6:	3f 93       	push	r19
     fa8:	4f 93       	push	r20
     faa:	5f 93       	push	r21
     fac:	6f 93       	push	r22
     fae:	7f 93       	push	r23
     fb0:	8f 93       	push	r24
     fb2:	9f 93       	push	r25
     fb4:	af 93       	push	r26
     fb6:	bf 93       	push	r27
     fb8:	ef 93       	push	r30
     fba:	ff 93       	push	r31
     fbc:	df 93       	push	r29
     fbe:	cf 93       	push	r28
     fc0:	cd b7       	in	r28, 0x3d	; 61
     fc2:	de b7       	in	r29, 0x3e	; 62
     fc4:	61 97       	sbiw	r28, 0x11	; 17
     fc6:	de bf       	out	0x3e, r29	; 62
     fc8:	cd bf       	out	0x3d, r28	; 61
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
     fca:	10 92 e9 00 	sts	0x00E9, r1
	return UEBCLX;
}

static inline u8 ReceivedSetupInt()
{
	return UEINTX & (1<<RXSTPI);
     fce:	80 91 e8 00 	lds	r24, 0x00E8

//	Endpoint 0 interrupt
ISR(USB_COM_vect)
{
    SetEP(0);
	if (!ReceivedSetupInt())
     fd2:	83 ff       	sbrs	r24, 3
     fd4:	0f c1       	rjmp	.+542    	; 0x11f4 <__vector_11+0x260>
		return;

	Setup setup;
	Recv((u8*)&setup,8);
     fd6:	fe 01       	movw	r30, r28
     fd8:	31 96       	adiw	r30, 0x01	; 1
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
	while (count--)
     fda:	9e 01       	movw	r18, r28
     fdc:	27 5f       	subi	r18, 0xF7	; 247
     fde:	3f 4f       	sbci	r19, 0xFF	; 255
     fe0:	03 c0       	rjmp	.+6      	; 0xfe8 <__vector_11+0x54>
		*data++ = UEDATX;
     fe2:	80 91 f1 00 	lds	r24, 0x00F1
     fe6:	81 93       	st	Z+, r24
	UEINTX = ~(1<<RXOUTI);
}

void Recv(volatile u8* data, u8 count)
{
	while (count--)
     fe8:	e2 17       	cp	r30, r18
     fea:	f3 07       	cpc	r31, r19
     fec:	d1 f7       	brne	.-12     	; 0xfe2 <__vector_11+0x4e>
		*data++ = UEDATX;
	
	RXLED1;					// light the RX LED
     fee:	28 9a       	sbi	0x05, 0	; 5
	RxLEDPulse = TX_RX_LED_PULSE_MS;	
     ff0:	84 e6       	ldi	r24, 0x64	; 100
     ff2:	80 93 98 01 	sts	0x0198, r24
	return UEINTX & (1<<RXSTPI);
}

static inline void ClearSetupInt()
{
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
     ff6:	82 ef       	ldi	r24, 0xF2	; 242
     ff8:	80 93 e8 00 	sts	0x00E8, r24

	Setup setup;
	Recv((u8*)&setup,8);
	ClearSetupInt();

	u8 requestType = setup.bmRequestType;
     ffc:	99 81       	ldd	r25, Y+1	; 0x01
	if (requestType & REQUEST_DEVICETOHOST)
     ffe:	97 ff       	sbrs	r25, 7
    1000:	05 c0       	rjmp	.+10     	; 0x100c <__vector_11+0x78>

volatile u8 _usbConfiguration = 0;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)));
    1002:	80 91 e8 00 	lds	r24, 0x00E8
    1006:	80 ff       	sbrs	r24, 0
    1008:	fc cf       	rjmp	.-8      	; 0x1002 <__vector_11+0x6e>
    100a:	03 c0       	rjmp	.+6      	; 0x1012 <__vector_11+0x7e>
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    100c:	8e ef       	ldi	r24, 0xFE	; 254
    100e:	80 93 e8 00 	sts	0x00E8, r24
		WaitIN();
	else
		ClearIN();

    bool ok = true;
	if (REQUEST_STANDARD == (requestType & REQUEST_TYPE))
    1012:	29 2f       	mov	r18, r25
    1014:	30 e0       	ldi	r19, 0x00	; 0
    1016:	c9 01       	movw	r24, r18
    1018:	80 76       	andi	r24, 0x60	; 96
    101a:	90 70       	andi	r25, 0x00	; 0
    101c:	89 2b       	or	r24, r25
    101e:	09 f0       	breq	.+2      	; 0x1022 <__vector_11+0x8e>
    1020:	c2 c0       	rjmp	.+388    	; 0x11a6 <__vector_11+0x212>
	{
		//	Standard Requests
		u8 r = setup.bRequest;
    1022:	8a 81       	ldd	r24, Y+2	; 0x02
		if (GET_STATUS == r)
    1024:	88 23       	and	r24, r24
    1026:	29 f4       	brne	.+10     	; 0x1032 <__vector_11+0x9e>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
    1028:	10 92 f1 00 	sts	0x00F1, r1
		if (GET_STATUS == r)
		{
			Send8(0);		// TODO
			Send8(0);
		}
		else if (CLEAR_FEATURE == r)
    102c:	10 92 f1 00 	sts	0x00F1, r1
    1030:	d6 c0       	rjmp	.+428    	; 0x11de <__vector_11+0x24a>
    1032:	81 30       	cpi	r24, 0x01	; 1
    1034:	09 f4       	brne	.+2      	; 0x1038 <__vector_11+0xa4>
    1036:	d3 c0       	rjmp	.+422    	; 0x11de <__vector_11+0x24a>
		{
		}
		else if (SET_FEATURE == r)
    1038:	83 30       	cpi	r24, 0x03	; 3
    103a:	09 f4       	brne	.+2      	; 0x103e <__vector_11+0xaa>
    103c:	d0 c0       	rjmp	.+416    	; 0x11de <__vector_11+0x24a>
		{
		}
		else if (SET_ADDRESS == r)
    103e:	85 30       	cpi	r24, 0x05	; 5
    1040:	49 f4       	brne	.+18     	; 0x1054 <__vector_11+0xc0>

volatile u8 _usbConfiguration = 0;

static inline void WaitIN(void)
{
	while (!(UEINTX & (1<<TXINI)));
    1042:	80 91 e8 00 	lds	r24, 0x00E8
    1046:	80 ff       	sbrs	r24, 0
    1048:	fc cf       	rjmp	.-8      	; 0x1042 <__vector_11+0xae>
		{
		}
		else if (SET_ADDRESS == r)
		{
			WaitIN();
			UDADDR = setup.wValueL | (1<<ADDEN);
    104a:	8b 81       	ldd	r24, Y+3	; 0x03
    104c:	80 68       	ori	r24, 0x80	; 128
    104e:	80 93 e3 00 	sts	0x00E3, r24
    1052:	c5 c0       	rjmp	.+394    	; 0x11de <__vector_11+0x24a>
		}
		else if (GET_DESCRIPTOR == r)
    1054:	86 30       	cpi	r24, 0x06	; 6
    1056:	09 f0       	breq	.+2      	; 0x105a <__vector_11+0xc6>
    1058:	7c c0       	rjmp	.+248    	; 0x1152 <__vector_11+0x1be>
u8 _cdcComposite = 0;

static
bool SendDescriptor(Setup& setup)
{
	u8 t = setup.wValueH;
    105a:	1c 81       	ldd	r17, Y+4	; 0x04
    105c:	ef 80       	ldd	r14, Y+7	; 0x07
    105e:	f8 84       	ldd	r15, Y+8	; 0x08
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
    1060:	12 30       	cpi	r17, 0x02	; 2
    1062:	c1 f5       	brne	.+112    	; 0x10d4 <__vector_11+0x140>
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    1064:	10 92 e9 00 	sts	0x00E9, r1
int _cmark;
int _cend;
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
    1068:	10 92 9b 01 	sts	0x019B, r1
    106c:	10 92 9a 01 	sts	0x019A, r1
	_cend = end;
    1070:	10 92 9d 01 	sts	0x019D, r1
    1074:	10 92 9c 01 	sts	0x019C, r1
static
bool SendConfiguration(int maxlen)
{
	//	Count and measure interfaces
	InitControl(0);	
	int interfaces = SendInterfaces();
    1078:	0e 94 b1 07 	call	0xf62	; 0xf62 <SendInterfaces()>
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);
    107c:	99 e0       	ldi	r25, 0x09	; 9
    107e:	fe 01       	movw	r30, r28
    1080:	39 96       	adiw	r30, 0x09	; 9
    1082:	df 01       	movw	r26, r30
    1084:	29 2f       	mov	r18, r25
    1086:	1d 92       	st	X+, r1
    1088:	2a 95       	dec	r18
    108a:	e9 f7       	brne	.-6      	; 0x1086 <__vector_11+0xf2>
    108c:	99 87       	std	Y+9, r25	; 0x09
    108e:	1a 87       	std	Y+10, r17	; 0x0a
    1090:	91 e0       	ldi	r25, 0x01	; 1
    1092:	9e 87       	std	Y+14, r25	; 0x0e
    1094:	90 e8       	ldi	r25, 0x80	; 128
    1096:	98 8b       	std	Y+16, r25	; 0x10
    1098:	9a ef       	ldi	r25, 0xFA	; 250
    109a:	99 8b       	std	Y+17, r25	; 0x11
    109c:	20 91 9a 01 	lds	r18, 0x019A
    10a0:	30 91 9b 01 	lds	r19, 0x019B
    10a4:	27 5f       	subi	r18, 0xF7	; 247
    10a6:	3f 4f       	sbci	r19, 0xFF	; 255
    10a8:	3c 87       	std	Y+12, r19	; 0x0c
    10aa:	2b 87       	std	Y+11, r18	; 0x0b
    10ac:	8d 87       	std	Y+13, r24	; 0x0d
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    10ae:	10 92 e9 00 	sts	0x00E9, r1
int _cmark;
int _cend;
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
    10b2:	10 92 9b 01 	sts	0x019B, r1
    10b6:	10 92 9a 01 	sts	0x019A, r1
	_cend = end;
    10ba:	f0 92 9d 01 	sts	0x019D, r15
    10be:	e0 92 9c 01 	sts	0x019C, r14
	int interfaces = SendInterfaces();
	ConfigDescriptor config = D_CONFIG(_cmark + sizeof(ConfigDescriptor),interfaces);

	//	Now send them
	InitControl(maxlen);
	USB_SendControl(0,&config,sizeof(ConfigDescriptor));
    10c2:	80 e0       	ldi	r24, 0x00	; 0
    10c4:	bf 01       	movw	r22, r30
    10c6:	49 e0       	ldi	r20, 0x09	; 9
    10c8:	50 e0       	ldi	r21, 0x00	; 0
    10ca:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
	SendInterfaces();
    10ce:	0e 94 b1 07 	call	0xf62	; 0xf62 <SendInterfaces()>
    10d2:	85 c0       	rjmp	.+266    	; 0x11de <__vector_11+0x24a>
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    10d4:	10 92 e9 00 	sts	0x00E9, r1
int _cmark;
int _cend;
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
    10d8:	10 92 9b 01 	sts	0x019B, r1
    10dc:	10 92 9a 01 	sts	0x019A, r1
	_cend = end;
    10e0:	f0 92 9d 01 	sts	0x019D, r15
    10e4:	e0 92 9c 01 	sts	0x019C, r14
	if (USB_CONFIGURATION_DESCRIPTOR_TYPE == t)
		return SendConfiguration(setup.wLength);

	InitControl(setup.wLength);
#ifdef HID_ENABLED
	if (HID_REPORT_DESCRIPTOR_TYPE == t)
    10e8:	12 32       	cpi	r17, 0x22	; 34
    10ea:	41 f4       	brne	.+16     	; 0x10fc <__vector_11+0x168>
		return HID_GetDescriptor(t);
    10ec:	82 e2       	ldi	r24, 0x22	; 34
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	0e 94 42 0a 	call	0x1484	; 0x1484 <HID_GetDescriptor(int)>
    10f4:	89 2b       	or	r24, r25
    10f6:	09 f4       	brne	.+2      	; 0x10fa <__vector_11+0x166>
    10f8:	76 c0       	rjmp	.+236    	; 0x11e6 <__vector_11+0x252>
    10fa:	71 c0       	rjmp	.+226    	; 0x11de <__vector_11+0x24a>
#endif

	u8 desc_length = 0;
	const u8* desc_addr = 0;
	if (USB_DEVICE_DESCRIPTOR_TYPE == t)
    10fc:	11 30       	cpi	r17, 0x01	; 1
    10fe:	79 f4       	brne	.+30     	; 0x111e <__vector_11+0x18a>
	{
		if (setup.wLength == 8)
    1100:	88 e0       	ldi	r24, 0x08	; 8
    1102:	e8 16       	cp	r14, r24
    1104:	f1 04       	cpc	r15, r1
    1106:	19 f4       	brne	.+6      	; 0x110e <__vector_11+0x17a>
			_cdcComposite = 1;
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	80 93 9e 01 	sts	0x019E, r24
		desc_addr = _cdcComposite ?  (const u8*)&USB_DeviceDescriptorA : (const u8*)&USB_DeviceDescriptor;
    110e:	80 91 9e 01 	lds	r24, 0x019E
    1112:	88 23       	and	r24, r24
    1114:	09 f0       	breq	.+2      	; 0x1118 <__vector_11+0x184>
    1116:	6b c0       	rjmp	.+214    	; 0x11ee <__vector_11+0x25a>
    1118:	ec eb       	ldi	r30, 0xBC	; 188
    111a:	f1 e0       	ldi	r31, 0x01	; 1
    111c:	13 c0       	rjmp	.+38     	; 0x1144 <__vector_11+0x1b0>
	}
	else if (USB_STRING_DESCRIPTOR_TYPE == t)
    111e:	13 30       	cpi	r17, 0x03	; 3
    1120:	09 f0       	breq	.+2      	; 0x1124 <__vector_11+0x190>
    1122:	61 c0       	rjmp	.+194    	; 0x11e6 <__vector_11+0x252>
	{
		if (setup.wValueL == 0)
    1124:	8b 81       	ldd	r24, Y+3	; 0x03
    1126:	88 23       	and	r24, r24
    1128:	19 f4       	brne	.+6      	; 0x1130 <__vector_11+0x19c>
			desc_addr = (const u8*)&STRING_LANGUAGE;
    112a:	ee e7       	ldi	r30, 0x7E	; 126
    112c:	f1 e0       	ldi	r31, 0x01	; 1
    112e:	0a c0       	rjmp	.+20     	; 0x1144 <__vector_11+0x1b0>
		else if (setup.wValueL == IPRODUCT) 
    1130:	82 30       	cpi	r24, 0x02	; 2
    1132:	19 f4       	brne	.+6      	; 0x113a <__vector_11+0x1a6>
			desc_addr = (const u8*)&STRING_IPRODUCT;
    1134:	e2 e8       	ldi	r30, 0x82	; 130
    1136:	f1 e0       	ldi	r31, 0x01	; 1
    1138:	05 c0       	rjmp	.+10     	; 0x1144 <__vector_11+0x1b0>
		else if (setup.wValueL == IMANUFACTURER)
    113a:	81 30       	cpi	r24, 0x01	; 1
    113c:	09 f0       	breq	.+2      	; 0x1140 <__vector_11+0x1ac>
    113e:	53 c0       	rjmp	.+166    	; 0x11e6 <__vector_11+0x252>
			desc_addr = (const u8*)&STRING_IMANUFACTURER;
    1140:	e4 ea       	ldi	r30, 0xA4	; 164
    1142:	f1 e0       	ldi	r31, 0x01	; 1
	}

	if (desc_addr == 0)
		return false;
	if (desc_length == 0)
		desc_length = pgm_read_byte(desc_addr);
    1144:	44 91       	lpm	r20, Z+

	USB_SendControl(TRANSFER_PGM,desc_addr,desc_length);
    1146:	80 e8       	ldi	r24, 0x80	; 128
    1148:	bf 01       	movw	r22, r30
    114a:	50 e0       	ldi	r21, 0x00	; 0
    114c:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
    1150:	46 c0       	rjmp	.+140    	; 0x11de <__vector_11+0x24a>
		}
		else if (GET_DESCRIPTOR == r)
		{
			ok = SendDescriptor(setup);
		}
		else if (SET_DESCRIPTOR == r)
    1152:	87 30       	cpi	r24, 0x07	; 7
    1154:	09 f4       	brne	.+2      	; 0x1158 <__vector_11+0x1c4>
    1156:	47 c0       	rjmp	.+142    	; 0x11e6 <__vector_11+0x252>
		{
			ok = false;
		}
		else if (GET_CONFIGURATION == r)
    1158:	88 30       	cpi	r24, 0x08	; 8
    115a:	21 f4       	brne	.+8      	; 0x1164 <__vector_11+0x1d0>
	return UEDATX;	
}

static inline void Send8(u8 d)
{
	UEDATX = d;
    115c:	81 e0       	ldi	r24, 0x01	; 1
    115e:	80 93 f1 00 	sts	0x00F1, r24
    1162:	3d c0       	rjmp	.+122    	; 0x11de <__vector_11+0x24a>
		}
		else if (GET_CONFIGURATION == r)
		{
			Send8(1);
		}
		else if (SET_CONFIGURATION == r)
    1164:	89 30       	cpi	r24, 0x09	; 9
    1166:	d9 f5       	brne	.+118    	; 0x11de <__vector_11+0x24a>
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
    1168:	23 70       	andi	r18, 0x03	; 3
    116a:	30 70       	andi	r19, 0x00	; 0
    116c:	23 2b       	or	r18, r19
    116e:	d9 f5       	brne	.+118    	; 0x11e6 <__vector_11+0x252>
    1170:	e1 ee       	ldi	r30, 0xE1	; 225
    1172:	f1 e0       	ldi	r31, 0x01	; 1
    1174:	91 e0       	ldi	r25, 0x01	; 1
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
		UECONX = 1;
    1176:	31 e0       	ldi	r19, 0x01	; 1
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
    1178:	26 e3       	ldi	r18, 0x36	; 54
static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
	{
		UENUM = i;
    117a:	90 93 e9 00 	sts	0x00E9, r25
		UECONX = 1;
    117e:	30 93 eb 00 	sts	0x00EB, r19
		UECFG0X = pgm_read_byte(_initEndpoints+i);
    1182:	84 91       	lpm	r24, Z+
    1184:	80 93 ec 00 	sts	0x00EC, r24
		UECFG1X = EP_DOUBLE_64;
    1188:	20 93 ed 00 	sts	0x00ED, r18
}

static
void InitEndpoints()
{
	for (u8 i = 1; i < sizeof(_initEndpoints); i++)
    118c:	9f 5f       	subi	r25, 0xFF	; 255
    118e:	31 96       	adiw	r30, 0x01	; 1
    1190:	95 30       	cpi	r25, 0x05	; 5
    1192:	99 f7       	brne	.-26     	; 0x117a <__vector_11+0x1e6>
		UENUM = i;
		UECONX = 1;
		UECFG0X = pgm_read_byte(_initEndpoints+i);
		UECFG1X = EP_DOUBLE_64;
	}
	UERST = 0x7E;	// And reset them
    1194:	8e e7       	ldi	r24, 0x7E	; 126
    1196:	80 93 ea 00 	sts	0x00EA, r24
	UERST = 0;
    119a:	10 92 ea 00 	sts	0x00EA, r1
		else if (SET_CONFIGURATION == r)
		{
			if (REQUEST_DEVICE == (requestType & REQUEST_RECIPIENT))
			{
				InitEndpoints();
				_usbConfiguration = setup.wValueL;
    119e:	8b 81       	ldd	r24, Y+3	; 0x03
    11a0:	80 93 99 01 	sts	0x0199, r24
    11a4:	1c c0       	rjmp	.+56     	; 0x11de <__vector_11+0x24a>
		{
		}
	}
	else
	{
		InitControl(setup.wLength);		//	Max length of transfer
    11a6:	8f 81       	ldd	r24, Y+7	; 0x07
    11a8:	98 85       	ldd	r25, Y+8	; 0x08
	UEDATX = d;
}

static inline void SetEP(u8 ep)
{
	UENUM = ep;
    11aa:	10 92 e9 00 	sts	0x00E9, r1
int _cmark;
int _cend;
void InitControl(int end)
{
	SetEP(0);
	_cmark = 0;
    11ae:	10 92 9b 01 	sts	0x019B, r1
    11b2:	10 92 9a 01 	sts	0x019A, r1
	_cend = end;
    11b6:	90 93 9d 01 	sts	0x019D, r25
    11ba:	80 93 9c 01 	sts	0x019C, r24

//	Handle CLASS_INTERFACE requests
static
bool ClassInterfaceRequest(Setup& setup)
{
	u8 i = setup.wIndex;
    11be:	8d 81       	ldd	r24, Y+5	; 0x05

#ifdef CDC_ENABLED
	if (CDC_ACM_INTERFACE == i)
    11c0:	88 23       	and	r24, r24
    11c2:	29 f4       	brne	.+10     	; 0x11ce <__vector_11+0x23a>
		return CDC_Setup(setup);
    11c4:	ce 01       	movw	r24, r28
    11c6:	01 96       	adiw	r24, 0x01	; 1
    11c8:	0e 94 68 04 	call	0x8d0	; 0x8d0 <CDC_Setup(Setup&)>
    11cc:	06 c0       	rjmp	.+12     	; 0x11da <__vector_11+0x246>
#endif

#ifdef HID_ENABLED
	if (HID_INTERFACE == i)
    11ce:	82 30       	cpi	r24, 0x02	; 2
    11d0:	51 f4       	brne	.+20     	; 0x11e6 <__vector_11+0x252>
		return HID_Setup(setup);
    11d2:	ce 01       	movw	r24, r28
    11d4:	01 96       	adiw	r24, 0x01	; 1
    11d6:	0e 94 13 09 	call	0x1226	; 0x1226 <HID_Setup(Setup&)>
	{
		InitControl(setup.wLength);		//	Max length of transfer
		ok = ClassInterfaceRequest(setup);
	}

	if (ok)
    11da:	88 23       	and	r24, r24
    11dc:	21 f0       	breq	.+8      	; 0x11e6 <__vector_11+0x252>
	while (!(UEINTX & (1<<TXINI)));
}

static inline void ClearIN(void)
{
	UEINTX = ~(1<<TXINI);
    11de:	8e ef       	ldi	r24, 0xFE	; 254
    11e0:	80 93 e8 00 	sts	0x00E8, r24
    11e4:	07 c0       	rjmp	.+14     	; 0x11f4 <__vector_11+0x260>
	UEINTX = ~((1<<RXSTPI) | (1<<RXOUTI) | (1<<TXINI));
}

static inline void Stall()
{
	UECONX = (1<<STALLRQ) | (1<<EPEN);
    11e6:	81 e2       	ldi	r24, 0x21	; 33
    11e8:	80 93 eb 00 	sts	0x00EB, r24
    11ec:	03 c0       	rjmp	.+6      	; 0x11f4 <__vector_11+0x260>
    11ee:	ee ec       	ldi	r30, 0xCE	; 206
    11f0:	f1 e0       	ldi	r31, 0x01	; 1
    11f2:	a8 cf       	rjmp	.-176    	; 0x1144 <__vector_11+0x1b0>
		ClearIN();
	else
	{
		Stall();
	}
}
    11f4:	61 96       	adiw	r28, 0x11	; 17
    11f6:	de bf       	out	0x3e, r29	; 62
    11f8:	cd bf       	out	0x3d, r28	; 61
    11fa:	cf 91       	pop	r28
    11fc:	df 91       	pop	r29
    11fe:	ff 91       	pop	r31
    1200:	ef 91       	pop	r30
    1202:	bf 91       	pop	r27
    1204:	af 91       	pop	r26
    1206:	9f 91       	pop	r25
    1208:	8f 91       	pop	r24
    120a:	7f 91       	pop	r23
    120c:	6f 91       	pop	r22
    120e:	5f 91       	pop	r21
    1210:	4f 91       	pop	r20
    1212:	3f 91       	pop	r19
    1214:	2f 91       	pop	r18
    1216:	1f 91       	pop	r17
    1218:	ff 90       	pop	r15
    121a:	ef 90       	pop	r14
    121c:	0f 90       	pop	r0
    121e:	0f be       	out	0x3f, r0	; 63
    1220:	0f 90       	pop	r0
    1222:	1f 90       	pop	r1
    1224:	18 95       	reti

00001226 <HID_Setup(Setup&)>:
{
	USB_Send(HID_TX, &id, 1);
	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
}

bool WEAK HID_Setup(Setup& setup)
    1226:	fc 01       	movw	r30, r24
{
	u8 r = setup.bRequest;
    1228:	91 81       	ldd	r25, Z+1	; 0x01
	u8 requestType = setup.bmRequestType;
    122a:	80 81       	ld	r24, Z
	if (REQUEST_DEVICETOHOST_CLASS_INTERFACE == requestType)
    122c:	81 3a       	cpi	r24, 0xA1	; 161
    122e:	31 f4       	brne	.+12     	; 0x123c <HID_Setup(Setup&)+0x16>
	{
		if (HID_GET_REPORT == r)
    1230:	91 30       	cpi	r25, 0x01	; 1
    1232:	89 f0       	breq	.+34     	; 0x1256 <HID_Setup(Setup&)+0x30>
    1234:	80 e0       	ldi	r24, 0x00	; 0
    1236:	93 30       	cpi	r25, 0x03	; 3
    1238:	89 f4       	brne	.+34     	; 0x125c <HID_Setup(Setup&)+0x36>
    123a:	0d c0       	rjmp	.+26     	; 0x1256 <HID_Setup(Setup&)+0x30>
			//Send8(_hid_protocol);	// TODO
			return true;
		}
	}
	
	if (REQUEST_HOSTTODEVICE_CLASS_INTERFACE == requestType)
    123c:	81 32       	cpi	r24, 0x21	; 33
    123e:	69 f4       	brne	.+26     	; 0x125a <HID_Setup(Setup&)+0x34>
	{
		if (HID_SET_PROTOCOL == r)
    1240:	9b 30       	cpi	r25, 0x0B	; 11
    1242:	21 f4       	brne	.+8      	; 0x124c <HID_Setup(Setup&)+0x26>
		{
			_hid_protocol = setup.wValueL;
    1244:	82 81       	ldd	r24, Z+2	; 0x02
    1246:	80 93 18 01 	sts	0x0118, r24
    124a:	05 c0       	rjmp	.+10     	; 0x1256 <HID_Setup(Setup&)+0x30>
			return true;
		}

		if (HID_SET_IDLE == r)
    124c:	9a 30       	cpi	r25, 0x0A	; 10
    124e:	29 f4       	brne	.+10     	; 0x125a <HID_Setup(Setup&)+0x34>
		{
			_hid_idle = setup.wValueL;
    1250:	82 81       	ldd	r24, Z+2	; 0x02
    1252:	80 93 19 01 	sts	0x0119, r24
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	08 95       	ret
			return true;
    125a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return false;
}
    125c:	08 95       	ret

0000125e <Keyboard_::write(unsigned char)>:
	_keyReport.keys[5] = 0;	
	_keyReport.modifiers = 0;
	sendReport(&_keyReport);
}

size_t Keyboard_::write(uint8_t c)
    125e:	ef 92       	push	r14
    1260:	ff 92       	push	r15
    1262:	0f 93       	push	r16
    1264:	1f 93       	push	r17
    1266:	8c 01       	movw	r16, r24
    1268:	e6 2e       	mov	r14, r22
{	
	uint8_t p = press(c);		// Keydown
    126a:	dc 01       	movw	r26, r24
    126c:	ed 91       	ld	r30, X+
    126e:	fc 91       	ld	r31, X
    1270:	04 80       	ldd	r0, Z+4	; 0x04
    1272:	f5 81       	ldd	r31, Z+5	; 0x05
    1274:	e0 2d       	mov	r30, r0
    1276:	09 95       	icall
    1278:	f8 2e       	mov	r15, r24
	uint8_t r = release(c);		// Keyup
    127a:	d8 01       	movw	r26, r16
    127c:	ed 91       	ld	r30, X+
    127e:	fc 91       	ld	r31, X
    1280:	06 80       	ldd	r0, Z+6	; 0x06
    1282:	f7 81       	ldd	r31, Z+7	; 0x07
    1284:	e0 2d       	mov	r30, r0
    1286:	c8 01       	movw	r24, r16
    1288:	6e 2d       	mov	r22, r14
    128a:	09 95       	icall
	return (p);					// just return the result of press() since release() almost always returns 1
}
    128c:	8f 2d       	mov	r24, r15
    128e:	90 e0       	ldi	r25, 0x00	; 0
    1290:	1f 91       	pop	r17
    1292:	0f 91       	pop	r16
    1294:	ff 90       	pop	r15
    1296:	ef 90       	pop	r14
    1298:	08 95       	ret

0000129a <global constructors keyed to Mouse>:

//================================================================================
//================================================================================
//	Mouse

Mouse_::Mouse_(void) : _buttons(0)
    129a:	10 92 a0 01 	sts	0x01A0, r1
    129e:	10 92 a4 01 	sts	0x01A4, r1
    12a2:	10 92 a3 01 	sts	0x01A3, r1

//================================================================================
//================================================================================
//	Keyboard

Keyboard_::Keyboard_(void) 
    12a6:	80 e3       	ldi	r24, 0x30	; 48
    12a8:	91 e0       	ldi	r25, 0x01	; 1
    12aa:	90 93 a2 01 	sts	0x01A2, r25
    12ae:	80 93 a1 01 	sts	0x01A1, r24
size_t Keyboard_::write(uint8_t c)
{	
	uint8_t p = press(c);		// Keydown
	uint8_t r = release(c);		// Keyup
	return (p);					// just return the result of press() since release() almost always returns 1
}
    12b2:	08 95       	ret

000012b4 <HID_SendReport(unsigned char, void const*, int)>:
int WEAK HID_GetDescriptor(int i)
{
	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
}

void WEAK HID_SendReport(u8 id, const void* data, int len)
    12b4:	ef 92       	push	r14
    12b6:	ff 92       	push	r15
    12b8:	0f 93       	push	r16
    12ba:	1f 93       	push	r17
    12bc:	df 93       	push	r29
    12be:	cf 93       	push	r28
    12c0:	0f 92       	push	r0
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	89 83       	std	Y+1, r24	; 0x01
    12c8:	8b 01       	movw	r16, r22
    12ca:	7a 01       	movw	r14, r20
{
	USB_Send(HID_TX, &id, 1);
    12cc:	84 e0       	ldi	r24, 0x04	; 4
    12ce:	be 01       	movw	r22, r28
    12d0:	6f 5f       	subi	r22, 0xFF	; 255
    12d2:	7f 4f       	sbci	r23, 0xFF	; 255
    12d4:	41 e0       	ldi	r20, 0x01	; 1
    12d6:	50 e0       	ldi	r21, 0x00	; 0
    12d8:	0e 94 9e 06 	call	0xd3c	; 0xd3c <USB_Send(unsigned char, void const*, int)>
	USB_Send(HID_TX | TRANSFER_RELEASE,data,len);
    12dc:	84 e4       	ldi	r24, 0x44	; 68
    12de:	b8 01       	movw	r22, r16
    12e0:	a7 01       	movw	r20, r14
    12e2:	0e 94 9e 06 	call	0xd3c	; 0xd3c <USB_Send(unsigned char, void const*, int)>
}
    12e6:	0f 90       	pop	r0
    12e8:	cf 91       	pop	r28
    12ea:	df 91       	pop	r29
    12ec:	1f 91       	pop	r17
    12ee:	0f 91       	pop	r16
    12f0:	ff 90       	pop	r15
    12f2:	ef 90       	pop	r14
    12f4:	08 95       	ret

000012f6 <Keyboard_::sendReport(KeyReport*)>:
{
}

void Keyboard_::sendReport(KeyReport* keys)
{
	HID_SendReport(2,keys,sizeof(KeyReport));
    12f6:	82 e0       	ldi	r24, 0x02	; 2
    12f8:	48 e0       	ldi	r20, 0x08	; 8
    12fa:	50 e0       	ldi	r21, 0x00	; 0
    12fc:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <HID_SendReport(unsigned char, void const*, int)>
}
    1300:	08 95       	ret

00001302 <Keyboard_::releaseAll()>:

	sendReport(&_keyReport);
	return 1;
}

void Keyboard_::releaseAll(void)
    1302:	fc 01       	movw	r30, r24
{
	_keyReport.keys[0] = 0;
    1304:	16 82       	std	Z+6, r1	; 0x06
	_keyReport.keys[1] = 0;	
    1306:	17 82       	std	Z+7, r1	; 0x07
	_keyReport.keys[2] = 0;
    1308:	10 86       	std	Z+8, r1	; 0x08
	_keyReport.keys[3] = 0;	
    130a:	11 86       	std	Z+9, r1	; 0x09
	_keyReport.keys[4] = 0;
    130c:	12 86       	std	Z+10, r1	; 0x0a
	_keyReport.keys[5] = 0;	
    130e:	13 86       	std	Z+11, r1	; 0x0b
	_keyReport.modifiers = 0;
    1310:	14 82       	std	Z+4, r1	; 0x04
	sendReport(&_keyReport);
    1312:	34 96       	adiw	r30, 0x04	; 4
    1314:	bf 01       	movw	r22, r30
    1316:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <Keyboard_::sendReport(KeyReport*)>
}
    131a:	08 95       	ret

0000131c <Keyboard_::release(unsigned char)>:
}

// release() takes the specified key out of the persistent key report and
// sends the report.  This tells the OS the key is no longer pressed and that
// it shouldn't be repeated any more.
size_t Keyboard_::release(uint8_t k) 
    131c:	dc 01       	movw	r26, r24
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
    131e:	68 38       	cpi	r22, 0x88	; 136
    1320:	10 f0       	brcs	.+4      	; 0x1326 <Keyboard_::release(unsigned char)+0xa>
		k = k - 136;
    1322:	68 58       	subi	r22, 0x88	; 136
    1324:	29 c0       	rjmp	.+82     	; 0x1378 <Keyboard_::release(unsigned char)+0x5c>
    1326:	e6 2f       	mov	r30, r22
    1328:	f0 e0       	ldi	r31, 0x00	; 0
	} else if (k >= 128) {	// it's a modifier key
    132a:	67 ff       	sbrs	r22, 7
    132c:	13 c0       	rjmp	.+38     	; 0x1354 <Keyboard_::release(unsigned char)+0x38>
		_keyReport.modifiers &= ~(1<<(k-128));
    132e:	e0 58       	subi	r30, 0x80	; 128
    1330:	f0 40       	sbci	r31, 0x00	; 0
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	02 c0       	rjmp	.+4      	; 0x133c <Keyboard_::release(unsigned char)+0x20>
    1338:	88 0f       	add	r24, r24
    133a:	99 1f       	adc	r25, r25
    133c:	ea 95       	dec	r30
    133e:	e2 f7       	brpl	.-8      	; 0x1338 <Keyboard_::release(unsigned char)+0x1c>
    1340:	80 95       	com	r24
    1342:	14 96       	adiw	r26, 0x04	; 4
    1344:	2c 91       	ld	r18, X
    1346:	14 97       	sbiw	r26, 0x04	; 4
    1348:	28 23       	and	r18, r24
    134a:	14 96       	adiw	r26, 0x04	; 4
    134c:	2c 93       	st	X, r18
    134e:	14 97       	sbiw	r26, 0x04	; 4
    1350:	60 e0       	ldi	r22, 0x00	; 0
    1352:	12 c0       	rjmp	.+36     	; 0x1378 <Keyboard_::release(unsigned char)+0x5c>
		k = 0;
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
    1354:	ed 59       	subi	r30, 0x9D	; 157
    1356:	fd 4f       	sbci	r31, 0xFD	; 253
    1358:	64 91       	lpm	r22, Z+
		if (!k) {
    135a:	66 23       	and	r22, r22
    135c:	19 f4       	brne	.+6      	; 0x1364 <Keyboard_::release(unsigned char)+0x48>
    135e:	20 e0       	ldi	r18, 0x00	; 0
    1360:	30 e0       	ldi	r19, 0x00	; 0
    1362:	1d c0       	rjmp	.+58     	; 0x139e <Keyboard_::release(unsigned char)+0x82>
			return 0;
		}
		if (k & 0x80) {							// it's a capital letter or other character reached with shift
    1364:	67 ff       	sbrs	r22, 7
    1366:	08 c0       	rjmp	.+16     	; 0x1378 <Keyboard_::release(unsigned char)+0x5c>
			_keyReport.modifiers &= ~(0x02);	// the left shift modifier
    1368:	14 96       	adiw	r26, 0x04	; 4
    136a:	8c 91       	ld	r24, X
    136c:	14 97       	sbiw	r26, 0x04	; 4
    136e:	8d 7f       	andi	r24, 0xFD	; 253
    1370:	14 96       	adiw	r26, 0x04	; 4
    1372:	8c 93       	st	X, r24
    1374:	14 97       	sbiw	r26, 0x04	; 4
			k &= 0x7F;
    1376:	6f 77       	andi	r22, 0x7F	; 127
    1378:	fd 01       	movw	r30, r26
    137a:	90 e0       	ldi	r25, 0x00	; 0
	}
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
		if (0 != k && _keyReport.keys[i] == k) {
    137c:	66 23       	and	r22, r22
    137e:	21 f0       	breq	.+8      	; 0x1388 <Keyboard_::release(unsigned char)+0x6c>
    1380:	86 81       	ldd	r24, Z+6	; 0x06
    1382:	86 17       	cp	r24, r22
    1384:	09 f4       	brne	.+2      	; 0x1388 <Keyboard_::release(unsigned char)+0x6c>
			_keyReport.keys[i] = 0x00;
    1386:	16 82       	std	Z+6, r1	; 0x06
		}
	}
	
	// Test the key report to see if k is present.  Clear it if it exists.
	// Check all positions in case the key is present more than once (which it shouldn't be)
	for (i=0; i<6; i++) {
    1388:	9f 5f       	subi	r25, 0xFF	; 255
    138a:	31 96       	adiw	r30, 0x01	; 1
    138c:	96 30       	cpi	r25, 0x06	; 6
    138e:	b1 f7       	brne	.-20     	; 0x137c <Keyboard_::release(unsigned char)+0x60>
		if (0 != k && _keyReport.keys[i] == k) {
			_keyReport.keys[i] = 0x00;
		}
	}

	sendReport(&_keyReport);
    1390:	cd 01       	movw	r24, r26
    1392:	14 96       	adiw	r26, 0x04	; 4
    1394:	bd 01       	movw	r22, r26
    1396:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <Keyboard_::sendReport(KeyReport*)>
    139a:	21 e0       	ldi	r18, 0x01	; 1
    139c:	30 e0       	ldi	r19, 0x00	; 0
	return 1;
}
    139e:	c9 01       	movw	r24, r18
    13a0:	08 95       	ret

000013a2 <Keyboard_::press(unsigned char)>:

// press() adds the specified key (printing, non-printing, or modifier)
// to the persistent key report and sends the report.  Because of the way 
// USB HID works, the host acts like the key remains pressed until we 
// call release(), releaseAll(), or otherwise clear the report and resend.
size_t Keyboard_::press(uint8_t k) 
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	dc 01       	movw	r26, r24
{
	uint8_t i;
	if (k >= 136) {			// it's a non-printing key (not a modifier)
    13a8:	68 38       	cpi	r22, 0x88	; 136
    13aa:	10 f0       	brcs	.+4      	; 0x13b0 <Keyboard_::press(unsigned char)+0xe>
		k = k - 136;
    13ac:	68 58       	subi	r22, 0x88	; 136
    13ae:	25 c0       	rjmp	.+74     	; 0x13fa <Keyboard_::press(unsigned char)+0x58>
    13b0:	e6 2f       	mov	r30, r22
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
	} else if (k >= 128) {	// it's a modifier key
    13b4:	67 ff       	sbrs	r22, 7
    13b6:	12 c0       	rjmp	.+36     	; 0x13dc <Keyboard_::press(unsigned char)+0x3a>
		_keyReport.modifiers |= (1<<(k-128));
    13b8:	e0 58       	subi	r30, 0x80	; 128
    13ba:	f0 40       	sbci	r31, 0x00	; 0
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	90 e0       	ldi	r25, 0x00	; 0
    13c0:	02 c0       	rjmp	.+4      	; 0x13c6 <Keyboard_::press(unsigned char)+0x24>
    13c2:	88 0f       	add	r24, r24
    13c4:	99 1f       	adc	r25, r25
    13c6:	ea 95       	dec	r30
    13c8:	e2 f7       	brpl	.-8      	; 0x13c2 <Keyboard_::press(unsigned char)+0x20>
    13ca:	14 96       	adiw	r26, 0x04	; 4
    13cc:	2c 91       	ld	r18, X
    13ce:	14 97       	sbiw	r26, 0x04	; 4
    13d0:	28 2b       	or	r18, r24
    13d2:	14 96       	adiw	r26, 0x04	; 4
    13d4:	2c 93       	st	X, r18
    13d6:	14 97       	sbiw	r26, 0x04	; 4
    13d8:	60 e0       	ldi	r22, 0x00	; 0
    13da:	0f c0       	rjmp	.+30     	; 0x13fa <Keyboard_::press(unsigned char)+0x58>
		k = 0;
	} else {				// it's a printing key
		k = pgm_read_byte(_asciimap + k);
    13dc:	ed 59       	subi	r30, 0x9D	; 157
    13de:	fd 4f       	sbci	r31, 0xFD	; 253
    13e0:	64 91       	lpm	r22, Z+
		if (!k) {
    13e2:	66 23       	and	r22, r22
    13e4:	d9 f1       	breq	.+118    	; 0x145c <Keyboard_::press(unsigned char)+0xba>
			setWriteError();
			return 0;
		}
		if (k & 0x80) {						// it's a capital letter or other character reached with shift
    13e6:	67 ff       	sbrs	r22, 7
    13e8:	08 c0       	rjmp	.+16     	; 0x13fa <Keyboard_::press(unsigned char)+0x58>
			_keyReport.modifiers |= 0x02;	// the left shift modifier
    13ea:	14 96       	adiw	r26, 0x04	; 4
    13ec:	8c 91       	ld	r24, X
    13ee:	14 97       	sbiw	r26, 0x04	; 4
    13f0:	82 60       	ori	r24, 0x02	; 2
    13f2:	14 96       	adiw	r26, 0x04	; 4
    13f4:	8c 93       	st	X, r24
    13f6:	14 97       	sbiw	r26, 0x04	; 4
			k &= 0x7F;
    13f8:	6f 77       	andi	r22, 0x7F	; 127
		}
	}
	
	// Add k to the key report only if it's not already present
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
    13fa:	16 96       	adiw	r26, 0x06	; 6
    13fc:	8c 91       	ld	r24, X
    13fe:	16 97       	sbiw	r26, 0x06	; 6
    1400:	86 17       	cp	r24, r22
    1402:	a9 f1       	breq	.+106    	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    1404:	17 96       	adiw	r26, 0x07	; 7
    1406:	8c 91       	ld	r24, X
    1408:	17 97       	sbiw	r26, 0x07	; 7
    140a:	86 17       	cp	r24, r22
    140c:	81 f1       	breq	.+96     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    140e:	18 96       	adiw	r26, 0x08	; 8
    1410:	8c 91       	ld	r24, X
    1412:	18 97       	sbiw	r26, 0x08	; 8
    1414:	86 17       	cp	r24, r22
    1416:	59 f1       	breq	.+86     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    1418:	19 96       	adiw	r26, 0x09	; 9
    141a:	8c 91       	ld	r24, X
    141c:	19 97       	sbiw	r26, 0x09	; 9
    141e:	86 17       	cp	r24, r22
    1420:	31 f1       	breq	.+76     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    1422:	1a 96       	adiw	r26, 0x0a	; 10
    1424:	8c 91       	ld	r24, X
    1426:	1a 97       	sbiw	r26, 0x0a	; 10
    1428:	86 17       	cp	r24, r22
    142a:	09 f1       	breq	.+66     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    142c:	1b 96       	adiw	r26, 0x0b	; 11
    142e:	8c 91       	ld	r24, X
    1430:	1b 97       	sbiw	r26, 0x0b	; 11
    1432:	86 17       	cp	r24, r22
    1434:	e1 f0       	breq	.+56     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    1436:	ed 01       	movw	r28, r26
    1438:	e0 e0       	ldi	r30, 0x00	; 0
    143a:	f0 e0       	ldi	r31, 0x00	; 0
    143c:	9e 2f       	mov	r25, r30
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
		
		for (i=0; i<6; i++) {
			if (_keyReport.keys[i] == 0x00) {
    143e:	8e 81       	ldd	r24, Y+6	; 0x06
    1440:	88 23       	and	r24, r24
    1442:	21 f4       	brne	.+8      	; 0x144c <Keyboard_::press(unsigned char)+0xaa>
				_keyReport.keys[i] = k;
    1444:	ea 0f       	add	r30, r26
    1446:	fb 1f       	adc	r31, r27
    1448:	66 83       	std	Z+6, r22	; 0x06
    144a:	06 c0       	rjmp	.+12     	; 0x1458 <Keyboard_::press(unsigned char)+0xb6>
				break;
    144c:	9f 5f       	subi	r25, 0xFF	; 255
    144e:	31 96       	adiw	r30, 0x01	; 1
    1450:	21 96       	adiw	r28, 0x01	; 1
	// and if there is an empty slot.
	if (_keyReport.keys[0] != k && _keyReport.keys[1] != k && 
		_keyReport.keys[2] != k && _keyReport.keys[3] != k &&
		_keyReport.keys[4] != k && _keyReport.keys[5] != k) {
		
		for (i=0; i<6; i++) {
    1452:	e6 30       	cpi	r30, 0x06	; 6
    1454:	f1 05       	cpc	r31, r1
    1456:	91 f7       	brne	.-28     	; 0x143c <Keyboard_::press(unsigned char)+0x9a>
			if (_keyReport.keys[i] == 0x00) {
				_keyReport.keys[i] = k;
				break;
			}
		}
		if (i == 6) {
    1458:	96 30       	cpi	r25, 0x06	; 6
    145a:	49 f4       	brne	.+18     	; 0x146e <Keyboard_::press(unsigned char)+0xcc>
    145c:	81 e0       	ldi	r24, 0x01	; 1
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	13 96       	adiw	r26, 0x03	; 3
    1462:	9c 93       	st	X, r25
    1464:	8e 93       	st	-X, r24
    1466:	12 97       	sbiw	r26, 0x02	; 2
    1468:	20 e0       	ldi	r18, 0x00	; 0
    146a:	30 e0       	ldi	r19, 0x00	; 0
    146c:	07 c0       	rjmp	.+14     	; 0x147c <Keyboard_::press(unsigned char)+0xda>
			setWriteError();
			return 0;
		}	
	}
	sendReport(&_keyReport);
    146e:	cd 01       	movw	r24, r26
    1470:	14 96       	adiw	r26, 0x04	; 4
    1472:	bd 01       	movw	r22, r26
    1474:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <Keyboard_::sendReport(KeyReport*)>
    1478:	21 e0       	ldi	r18, 0x01	; 1
    147a:	30 e0       	ldi	r19, 0x00	; 0
	return 1;
}
    147c:	c9 01       	movw	r24, r18
    147e:	df 91       	pop	r29
    1480:	cf 91       	pop	r28
    1482:	08 95       	ret

00001484 <HID_GetDescriptor(int)>:
	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
}

int WEAK HID_GetDescriptor(int i)
{
	return USB_SendControl(TRANSFER_PGM,_hidReportDescriptor,sizeof(_hidReportDescriptor));
    1484:	80 e8       	ldi	r24, 0x80	; 128
    1486:	65 ee       	ldi	r22, 0xE5	; 229
    1488:	71 e0       	ldi	r23, 0x01	; 1
    148a:	45 e6       	ldi	r20, 0x65	; 101
    148c:	50 e0       	ldi	r21, 0x00	; 0
    148e:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
}
    1492:	08 95       	ret

00001494 <HID_GetInterface(unsigned char*)>:
u8 _hid_protocol = 1;
u8 _hid_idle = 1;

#define WEAK __attribute__ ((weak))

int WEAK HID_GetInterface(u8* interfaceNum)
    1494:	fc 01       	movw	r30, r24
{
	interfaceNum[0] += 1;	// uses 1
    1496:	80 81       	ld	r24, Z
    1498:	8f 5f       	subi	r24, 0xFF	; 255
    149a:	80 83       	st	Z, r24
	return USB_SendControl(TRANSFER_PGM,&_hidInterface,sizeof(_hidInterface));
    149c:	80 e8       	ldi	r24, 0x80	; 128
    149e:	6a e4       	ldi	r22, 0x4A	; 74
    14a0:	72 e0       	ldi	r23, 0x02	; 2
    14a2:	49 e1       	ldi	r20, 0x19	; 25
    14a4:	50 e0       	ldi	r21, 0x00	; 0
    14a6:	0e 94 17 06 	call	0xc2e	; 0xc2e <USB_SendControl(unsigned char, void const*, int)>
}
    14aa:	08 95       	ret

000014ac <__mulsi3>:
    14ac:	62 9f       	mul	r22, r18
    14ae:	d0 01       	movw	r26, r0
    14b0:	73 9f       	mul	r23, r19
    14b2:	f0 01       	movw	r30, r0
    14b4:	82 9f       	mul	r24, r18
    14b6:	e0 0d       	add	r30, r0
    14b8:	f1 1d       	adc	r31, r1
    14ba:	64 9f       	mul	r22, r20
    14bc:	e0 0d       	add	r30, r0
    14be:	f1 1d       	adc	r31, r1
    14c0:	92 9f       	mul	r25, r18
    14c2:	f0 0d       	add	r31, r0
    14c4:	83 9f       	mul	r24, r19
    14c6:	f0 0d       	add	r31, r0
    14c8:	74 9f       	mul	r23, r20
    14ca:	f0 0d       	add	r31, r0
    14cc:	65 9f       	mul	r22, r21
    14ce:	f0 0d       	add	r31, r0
    14d0:	99 27       	eor	r25, r25
    14d2:	72 9f       	mul	r23, r18
    14d4:	b0 0d       	add	r27, r0
    14d6:	e1 1d       	adc	r30, r1
    14d8:	f9 1f       	adc	r31, r25
    14da:	63 9f       	mul	r22, r19
    14dc:	b0 0d       	add	r27, r0
    14de:	e1 1d       	adc	r30, r1
    14e0:	f9 1f       	adc	r31, r25
    14e2:	bd 01       	movw	r22, r26
    14e4:	cf 01       	movw	r24, r30
    14e6:	11 24       	eor	r1, r1
    14e8:	08 95       	ret

000014ea <__udivmodsi4>:
    14ea:	a1 e2       	ldi	r26, 0x21	; 33
    14ec:	1a 2e       	mov	r1, r26
    14ee:	aa 1b       	sub	r26, r26
    14f0:	bb 1b       	sub	r27, r27
    14f2:	fd 01       	movw	r30, r26
    14f4:	0d c0       	rjmp	.+26     	; 0x1510 <__udivmodsi4_ep>

000014f6 <__udivmodsi4_loop>:
    14f6:	aa 1f       	adc	r26, r26
    14f8:	bb 1f       	adc	r27, r27
    14fa:	ee 1f       	adc	r30, r30
    14fc:	ff 1f       	adc	r31, r31
    14fe:	a2 17       	cp	r26, r18
    1500:	b3 07       	cpc	r27, r19
    1502:	e4 07       	cpc	r30, r20
    1504:	f5 07       	cpc	r31, r21
    1506:	20 f0       	brcs	.+8      	; 0x1510 <__udivmodsi4_ep>
    1508:	a2 1b       	sub	r26, r18
    150a:	b3 0b       	sbc	r27, r19
    150c:	e4 0b       	sbc	r30, r20
    150e:	f5 0b       	sbc	r31, r21

00001510 <__udivmodsi4_ep>:
    1510:	66 1f       	adc	r22, r22
    1512:	77 1f       	adc	r23, r23
    1514:	88 1f       	adc	r24, r24
    1516:	99 1f       	adc	r25, r25
    1518:	1a 94       	dec	r1
    151a:	69 f7       	brne	.-38     	; 0x14f6 <__udivmodsi4_loop>
    151c:	60 95       	com	r22
    151e:	70 95       	com	r23
    1520:	80 95       	com	r24
    1522:	90 95       	com	r25
    1524:	9b 01       	movw	r18, r22
    1526:	ac 01       	movw	r20, r24
    1528:	bd 01       	movw	r22, r26
    152a:	cf 01       	movw	r24, r30
    152c:	08 95       	ret

0000152e <__tablejump2__>:
    152e:	ee 0f       	add	r30, r30
    1530:	ff 1f       	adc	r31, r31

00001532 <__tablejump__>:
    1532:	05 90       	lpm	r0, Z+
    1534:	f4 91       	lpm	r31, Z+
    1536:	e0 2d       	mov	r30, r0
    1538:	09 94       	ijmp

0000153a <_exit>:
    153a:	f8 94       	cli

0000153c <__stop_program>:
    153c:	ff cf       	rjmp	.-2      	; 0x153c <__stop_program>

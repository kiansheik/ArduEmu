package emulator.processor;

public class Processor {

    private final short[] PROGMEM = new short[0x800];
    private final byte[] DATAMEM = new byte[0x300];
    private int PC = 0;
    private final byte[] EEPROM = new byte[256];
    private long CYCLES = 0L;
    private final StatusRegister sReg = new StatusRegister();
    /* --------------------------------------------------------- */
    public static final int SREG = 0x5f;
    private static final short RAMEND = 0x02ff;
    public static final int SPL = 0x5d;
    public static final int SPH = 0x5e;
    private static final int LByteMask = 0x00ff;
    private static final int HByteMask = 0xff00;
    public static final int X_LOW = 0x1A;
    public static final int X_HIGH = 0x1B;
    public static final int Y_LOW = 0x1C;
    public static final int Y_HIGH = 0x1D;
    public static final int Z_LOW = 0x1E;
    public static final int Z_HIGH = 0x1F;

    private class StatusRegister {

        private static final int _C = 1;
        private static final int _Z = 1 << 1;
        private static final int _N = 1 << 2;
        private static final int _V = 1 << 3;
        private static final int _S = 1 << 4;
        private static final int _H = 1 << 5;
        private static final int _T = 1 << 6;
        private static final int _I = 1 << 7;
        private StatusRegister() {
            reset();
        }
        private void reset() {
            C(true);
            Z(true);
            N(true);
            V(true);
            S(true);
            H(true);
            T(true);
            I(true);
        }
        boolean C() {
            return read(_C);
        }
        void C(boolean b) {
            write(_C, b);
        }
        boolean Z() {
            return read(_Z);
        }
        void Z(boolean b) {
            write(_Z, b);
        }
        boolean N() {
            return read(_N);
        }
        void N(boolean b) {
            write(_N, b);
        }
        boolean V() {
            return read(_V);
        }
        void V(boolean b) {
            write(_V, b);
        }
        boolean S() {
            return read(_S);
        }
        void S(boolean b) {
            write(_S, b);
        }
        boolean H() {
            return read(_H);
        }
        void H(boolean b) {
            write(_H, b);
        }
        boolean T() {
            return read(_T);
        }
        void T(boolean b) {
            write(_T, b);
        }
        boolean I() {
            return read(_I);
        }
        void I(boolean b) {
            write(_I, b);
        }
        private boolean read(int mask) {
            return (readData(SREG) & mask) > 0;
        }
        private void write(int mask, boolean bit) {
            if (bit)
                writeData(SREG, (byte) (readData(SREG) | mask));
            else
                writeData(SREG, (byte) (readData(SREG) & ~mask));
        }
    }
    public Processor() {
        reset();
    }
    private void reset() {
        writeSP(RAMEND);
        CYCLES = 0L;
        PC = 0;
        sReg.reset();
    }
    public void invokeInst(short inst) {
        // Cat 0
        // ---- ---- ---- ----
        int maskInt = (0xffff & inst);
OUTER:  switch (maskInt) {
            case 0x9519:
                eicall(inst);
                break;               // 1001 0101 0001 1001 | EICALL
            case 0x9419:
                eijmp(inst);
                break;                // 1001 0100 0001 1001 | EIJMP
            case 0x95D8:
                elpm(inst);
                break;                 // 1001 0101 1101 1000 | ELPM
            case 0x95F8:
                espm(inst);
                break;                 // 1001 0101 1111 1000 | ESPM 
            case 0x9509:
                icall(inst);
                break;                // 1001 0101 0000 1001 | ICALL
            case 0x9409:
                ijmp(inst);
                break;                 // 1001 0100 0000 1001 | IJMP 
            case 0x95C8:
                lpm(inst);
                break;                  // 1001 0101 1100 1000 | LPM
            case 0x0000:
                nop(inst);
                break;                  // 0000 0000 0000 0000 | NOP 
            case 0x9508:
                ret(inst);
                break;                  // 1001 0101 0000 1000 | RET
            case 0x9518:
                reti(inst);
                break;                 // 1001 0101 0001 1000 | RETI 
            case 0x9588:
                sleep(inst);
                break;                // 1001 0101 1000 1000 | SLEEP
            case 0x95E8:
                spm(inst);
                break;                  // 1001 0101 1110 1000 | SPM 
            case 0x95A8:
                wdr(inst);
                break;                  // 1001 0101 1010 1000 | WDR
            case 0x9598:
                _break(inst);
                break;               // 1001 0101 1001 1000 | BREAK 

            default:
                // Cat 1
                // ---- --rd dddd rrrr
                int innerMaskInt = maskInt & 0xfc00;
                switch (innerMaskInt) {
                    case 0x1c00:
                        adc(inst);
                        break OUTER;          // 0001 11rd dddd rrrr | ADC or ROL
                    case 0x0C00:
                        add(inst);
                        break OUTER;          // 0000 11rd dddd rrrr | ADD or LSL
                    case 0x2000:
                        and(inst);
                        break OUTER;          // 0010 00rd dddd rrrr | AND or TST 
                    case 0x1400:
                        cp(inst);
                        break OUTER;           // 0001 01rd dddd rrrr | CP 
                    case 0x0400:
                        cpc(inst);
                        break OUTER;          // 0000 01rd dddd rrrr | CPC 
                    case 0x1000:
                        cpse(inst);
                        break OUTER;         // 0001 00rd dddd rrrr | CPSE 
                    case 0x2400:
                        eor(inst);
                        break OUTER;          // 0010 01rd dddd rrrr | EOR or CLR 
                    case 0x2C00:
                        mov(inst);
                        break OUTER;          // 0010 11rd dddd rrrr | MOV 
                    case 0x9C00:
                        mul(inst);
                        break OUTER;          // 1001 11rd dddd rrrr | MUL 
                    case 0x2800:
                        or(inst);
                        break OUTER;           // 0010 10rd dddd rrrr | OR 
                    case 0x0800:
                        sbc(inst);
                        break OUTER;          // 0000 10rd dddd rrrr | SBC 
                    case 0x1800:
                        sub(inst);
                        break OUTER;          // 0001 10rd dddd rrrr | SUB 
                }
                throw new Error("Invalid instruction: " + inst);
        }
    }
    private void eicall(short inst) {
    }
    private void eijmp(short inst) {
    }
    private void elpm(short inst) {
    }
    private void espm(short inst) {
    }
    private void icall(short inst) {
    }
    private void ijmp(short inst) {
    }
    private void lpm(short inst) {
        short load = readProgMem(readZ() / 2); // Z is a byte address, progmem is short addressed
        writeReg(0, (byte) ((readZ() & 0x1) == 1 ? (load >>> 8) : load));
        CYCLES += 3;
    }
    private void nop(short inst) {
        CYCLES += 1;
    }
    private void ret(short inst) {
        incSP();
        PC = readSP();
        CYCLES += 4;
    }
    private void reti(short inst) {
        ret(inst);
        sReg.I(true);
    }
    private void sleep(short inst) {
    }
    private void spm(short inst) {
        short r0r1 = readShortData(0, 1);
        short z = readZ();
        writeProgMem(z, r0r1);
    }
    private void wdr(short inst) {
    }
    private void _break(short inst) {
    }
    private static int getRrAddrCat1(short inst) {
        return ((inst & 0x200) >>> 5) | 0xf & inst;
    }
    private static int getRdAddrCat1(short inst) {
        return (inst >>> 4) & 0x1f;
    }
    private static boolean isAddCarryBit(int rd, int rr, int result, int bit) {
        return (((rd & rr) | (rr & ~result) | (~result & rd)) & (1 << bit)) != 0;
    }
    private static boolean isAddOverflow(int rd, int rr, int result) {
        return (((rd & rr & ~result) | (~rd & ~rr & result)) & 0x80) != 0;
    }
    private void adc(short inst) {
        int r = getRrAddrCat1(inst);
        int d = getRdAddrCat1(inst);
        int rd = readReg(d);
        int rr = readReg(r);
        int result = rd + rr + boolToInt(sReg.C());
        sReg.H(isAddCarryBit(rd, rr, result, 3));
        sReg.V(isAddOverflow(rd, rr, result));
        sReg.N((result & 0x80) != 0);
        sReg.S(sReg.N() ^ sReg.V());
        sReg.Z((result & 0xff) == 0);
        sReg.C(isAddCarryBit(rd, rr, result, 7));
        writeReg(d, (byte) result);
        CYCLES += 1;
    }
    private void add(short inst) {
        int r = getRrAddrCat1(inst);
        int d = getRdAddrCat1(inst);
        int rd = readReg(d);
        int rr = readReg(r);
        int result = rd + rr;
        sReg.H(isAddCarryBit(rd, rr, result, 3));
        sReg.V(isAddOverflow(rd, rr, result));
        sReg.N((result & 0x80) != 0);
        sReg.S(sReg.N() ^ sReg.V());
        sReg.Z((result & 0xff) == 0);
        sReg.C(isAddCarryBit(rd, rr, result, 7));
        writeReg(d, (byte) result);
        CYCLES += 1;
    }
    private void and(short inst) {
    }
    private void cp(short inst) {
    }
    private void cpc(short inst) {
    }
    private void cpse(short inst) {
    }
    private void eor(short inst) {
    }
    private void mov(short inst) {
    }
    private void mul(short inst) {
    }
    private void or(short inst) {
    }
    private void sbc(short inst) {
    }
    private void sub(short inst) {
    }
    public StatusRegister getSReg() {
        return sReg;
    }
    public byte readReg(int addr) {
        return readData(addr);
    }
    public void writeReg(int addr, byte b) {
        writeData(addr, b);
    }
    public byte readData(int addr) {
        return DATAMEM[addr];
    }
    public void writeData(int addr, byte b) {
        DATAMEM[addr] = b;
    }
    public short readProgMem(int addr) {
        return PROGMEM[addr];
    }
    public void writeProgMem(int addr, short data) {
        PROGMEM[addr] = data;
    }
    public short readSP() {
        return (short) (0x07ff & readShortData(SPL, SPH));
    }
    public void writeSP(short sp) {
        writeShortData(SPL, SPH, (short) (0x07ff & sp));
    }
    public void incSP() {
        writeSP((short) (readSP() + 2));
    }
    public void decSP() {
        writeSP((short) (readSP() - 2));
    }
    public short readX() {
        return readShortData(X_LOW, X_HIGH);
    }
    public void writeX(short x) {
        writeShortData(X_LOW, X_HIGH, x);
    }
    public short readY() {
        return readShortData(Y_LOW, Y_HIGH);
    }
    public void writeY(short y) {
        writeShortData(Y_LOW, Y_HIGH, y);
    }
    public short readZ() {
        return readShortData(Z_LOW, Z_HIGH);
    }
    public void writeZ(short z) {
        writeShortData(Z_LOW, Z_HIGH, z);
    }
    private short readShortData(int lowAddr, int highAddr) {
        return readShortByteArray(DATAMEM, lowAddr, highAddr);
    }
    private void writeShortData(int lowAddr, int highAddr, short x) {
        writeShortByteWarray(DATAMEM, lowAddr, highAddr, x);
    }
    private short readShortByteArray(byte[] byteArray, int lowAddr, int highAddr) {
        return (short) (byteToInt(byteArray[highAddr]) << 8 | byteToInt(byteArray[lowAddr]));
    }
    private void writeShortByteWarray(byte[] byteArray, int lowAddr, int highAddr, short x) {
        byteArray[lowAddr] = (byte) (LByteMask & x);
        byteArray[highAddr] = (byte) ((HByteMask & x) >>> 8);
    }
    private static int byteToInt(byte b) {
        return (LByteMask & (int) b);
    }
    private static int boolToInt(boolean b) {
        return b ? 1 : 0;
    }
    public static void main(String[] args) {
        Processor p = new Processor();
        int Rd = 0xf;
        int Rr = 0x9;
        p.writeReg(Rd, (byte) 32);
        p.writeReg(Rr, (byte) 15);
        int inst = 0x1c00 | ((Rr & 0x10) << 5) | (Rd << 4) | (Rr & 0xf);
        System.out.printf("0x%x\n", inst);
        p.invokeInst((short) inst);
        int expected = 32 + 15 + 1;
        System.out.println("stuff: "+(expected == p.readReg(Rd)));
    }
}
package emulator.processor;

import emulator.EmuMath;
import emulator.memory.MemData;
import emulator.memory.MemEEProm;
import emulator.memory.MemProg;

public class Processor {

    /**
     * Data memory
     * 0x0000 - 0x001f -> registers
     * 0x0020 - 0x005f -> 64 I/O registers
     * 0x0060 - 0x00ff -> 160 external I/O registers
     * 0x0100 - 0x02ff -> 512 bytes of internal SRAM
     */
    private final MemProg memProg = new MemProg();
    private final MemData memData = new MemData();
    private final MemEEProm memEEProm = new MemEEProm();
    private final byte[] EEPROM = new byte[256];
    private int PC = 0;
    private long CYCLES = 0L;
    private static final short RAMEND = 0x02ff;
    public static final int SPL = 0x5d;
    public static final int SPH = 0x5e;
    private static final int LByteMask = 0x00ff;
    private static final int HByteMask = 0xff00;
    public static final int X_LOW = 0x1A;
    public static final int X_HIGH = 0x1B;
    public static final int Y_LOW = 0x1C;
    public static final int Y_HIGH = 0x1D;
    public static final int Z_LOW = 0x1E;
    public static final int Z_HIGH = 0x1F;
    public Processor() {
        reset();
    }
    private void reset() {
        writeSP(RAMEND);
        CYCLES = 0L;
        PC = 0;
        resetSReg();
    }
    public void resetSReg() {
        for (StatusRegister r : StatusRegister.values())
            r.write(true, memData);
    }
    public void invokeInst(short inst) {
        // Cat 0
        // ---- ---- ---- ----
        int maskInt = (0xffff & inst);
OUTER:  switch (maskInt) {
            case 0x9519:
                eicall(inst);
                break;               // 1001 0101 0001 1001 | EICALL
            case 0x9419:
                eijmp(inst);
                break;                // 1001 0100 0001 1001 | EIJMP
            case 0x95D8:
                elpm(inst);
                break;                 // 1001 0101 1101 1000 | ELPM
            case 0x95F8:
                espm(inst);
                break;                 // 1001 0101 1111 1000 | ESPM 
            case 0x9509:
                icall(inst);
                break;                // 1001 0101 0000 1001 | ICALL
            case 0x9409:
                ijmp(inst);
                break;                 // 1001 0100 0000 1001 | IJMP 
            case 0x95C8:
                lpm(inst);
                break;                  // 1001 0101 1100 1000 | LPM
            case 0x0000:
                nop(inst);
                break;                  // 0000 0000 0000 0000 | NOP 
            case 0x9508:
                ret(inst);
                break;                  // 1001 0101 0000 1000 | RET
            case 0x9518:
                reti(inst);
                break;                 // 1001 0101 0001 1000 | RETI 
            case 0x9588:
                sleep(inst);
                break;                // 1001 0101 1000 1000 | SLEEP
            case 0x95E8:
                spm(inst);
                break;                  // 1001 0101 1110 1000 | SPM 
            case 0x95A8:
                wdr(inst);
                break;                  // 1001 0101 1010 1000 | WDR
            case 0x9598:
                _break(inst);
                break;               // 1001 0101 1001 1000 | BREAK 

            default:
                // Cat 1
                // ---- --rd dddd rrrr
                int innerMaskInt = maskInt & 0xfc00;
                switch (innerMaskInt) {
                    case 0x1c00:
                        adc(inst);
                        break OUTER;          // 0001 11rd dddd rrrr | ADC or ROL
                    case 0x0C00:
                        add(inst);
                        break OUTER;          // 0000 11rd dddd rrrr | ADD or LSL
                    case 0x2000:
                        and(inst);
                        break OUTER;          // 0010 00rd dddd rrrr | AND or TST 
                    case 0x1400:
                        cp(inst);
                        break OUTER;           // 0001 01rd dddd rrrr | CP 
                    case 0x0400:
                        cpc(inst);
                        break OUTER;          // 0000 01rd dddd rrrr | CPC 
                    case 0x1000:
                        cpse(inst);
                        break OUTER;         // 0001 00rd dddd rrrr | CPSE 
                    case 0x2400:
                        eor(inst);
                        break OUTER;          // 0010 01rd dddd rrrr | EOR or CLR 
                    case 0x2C00:
                        mov(inst);
                        break OUTER;          // 0010 11rd dddd rrrr | MOV 
                    case 0x9C00:
                        mul(inst);
                        break OUTER;          // 1001 11rd dddd rrrr | MUL 
                    case 0x2800:
                        or(inst);
                        break OUTER;           // 0010 10rd dddd rrrr | OR 
                    case 0x0800:
                        sbc(inst);
                        break OUTER;          // 0000 10rd dddd rrrr | SBC 
                    case 0x1800:
                        sub(inst);
                        break OUTER;          // 0001 10rd dddd rrrr | SUB 
                }
                throw new Error("Invalid instruction: " + inst);
        }
    }
    private void eicall(short inst) {   
    }
    private void eijmp(short inst) {
    }
    private void elpm(short inst) {
    }
    private void espm(short inst) {
    }
    private void icall(short inst) {
    }
    private void ijmp(short inst) {
    }
    private void lpm(short inst) {
        short load = memProg.read((short) (memData.readZ() / 2)); // Z is a byte address, progmem is short addressed
        memData.write(0, (byte) ((memData.readZ() & 0x1) == 1 ? (load >>> 8) : load));
        CYCLES += 3;
    }
    private void nop(short inst) {
        CYCLES += 1;
    }
    private void ret(short inst) {
        incSP();
        PC = readSP();
        CYCLES += 4;
    }
    private void reti(short inst) {
        ret(inst);
        StatusRegister.I.write(true, memData);
    }
    private void sleep(short inst) {
    }
    private void spm(short inst) {
        short r0r1 = memData.readShort(0, 1);
        short z = memData.readZ();
        memProg.write(z, r0r1);
    }
    private void wdr(short inst) {
    }
    private void _break(short inst) {
    }
    private void adc(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd + rr + EmuMath.boolToInt(StatusRegister.C.read(memData));
        StatusRegister.H.write(EmuMath.isAddCarryBit(rd, rr, result, 3), memData);
        StatusRegister.V.write(EmuMath.isAddOverflow(rd, rr, result), memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        StatusRegister.C.write(EmuMath.isAddCarryBit(rd, rr, result, 7), memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void add(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd + rr;
        StatusRegister.H.write(EmuMath.isAddCarryBit(rd, rr, result, 3), memData);
        StatusRegister.V.write(EmuMath.isAddOverflow(rd, rr, result), memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        StatusRegister.C.write(EmuMath.isAddCarryBit(rd, rr, result, 7), memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void and(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd & rr;
        StatusRegister.V.write(false, memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void cp(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd - rr;
        StatusRegister.H.write(EmuMath.isSubCarryBit(rd, rr, result, 3), memData);
        StatusRegister.V.write(EmuMath.isSubOverflow(rd, rr, result), memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        StatusRegister.C.write(EmuMath.isSubCarryBit(rd, rr, result, 7), memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void cpc(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd - rr - EmuMath.boolToInt(StatusRegister.C.read(memData));
        StatusRegister.H.write(EmuMath.isSubCarryBit(rd, rr, result, 3), memData);
        StatusRegister.V.write(EmuMath.isSubOverflow(rd, rr, result), memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0 ? StatusRegister.Z.read(memData) : false, memData);
        StatusRegister.C.write(EmuMath.isSubCarryBit(rd, rr, result, 7), memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void cpse(short inst) {
    }
    private void eor(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rd ^ rr;
        StatusRegister.V.write(false, memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        memData.write(d, (byte) result);
        CYCLES += 1;
    }
    private void mov(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rr = memData.read(r);
        memData.write(d, (byte) rr);
        CYCLES += 1;
    }
    private void mul(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rr = (0xff & memData.read(r));
        int rd = (0xff & memData.read(d));
        int result = rr * rd;
        StatusRegister.C.write((result & 0x8000) != 0, memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        memData.writeShort(0, 1, (short) result);
        CYCLES += 2;
    }
    private void or(short inst) {
        int r = EmuMath.getRrAddrCat1(inst);
        int d = EmuMath.getRdAddrCat1(inst);
        int rd = memData.read(d);
        int rr = memData.read(r);
        int result = rr | rd;
        StatusRegister.V.write(false, memData);
        StatusRegister.N.write((result & 0x80) != 0, memData);
        StatusRegister.S.write(StatusRegister.N.read(memData) ^ StatusRegister.V.read(memData), memData);
        StatusRegister.Z.write((result & 0xff) == 0, memData);
        memData.write(rd, (byte) result);
    }
    private void sbc(short inst) {
    }
    private void sub(short inst) {
    }
    public short readSP() {
        return (short) (0x07ff & memData.readShort(SPL, SPH));
    }
    public void writeSP(short sp) {
        memData.writeShort(SPL, SPH, (short) (0x07ff & sp));
    }
    public void incSP() {
        writeSP((short) (readSP() + 2));
    }
    public void decSP() {
        writeSP((short) (readSP() - 2));
    }
    public static void main(String[] args) {
        Processor p = new Processor();
        int Rd = 0xf;
        int Rr = 0x9;
        p.memData.write(Rd, (byte) 32);
        p.memData.write(Rr, (byte) 15);
        int inst = 0x0c00 | ((Rr & 0x10) << 5) | (Rd << 4) | (Rr & 0xf);
        System.out.printf("0x%x\n", inst);
        p.invokeInst((short) inst);
        int expected = 32 + 15;
        System.out.println("stuff: " + (expected == p.memData.read(Rd)));
    }
}